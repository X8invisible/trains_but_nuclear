(* Module for axiomatizing type "short_short_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_short_integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type short_short_integer =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = short_short_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type short_short_integer__ref =
  { mutable short_short_integer__content : short_short_integer }
 
 function short_short_integer__ref_short_short_integer__content__projection 
   (a : short_short_integer__ref) : short_short_integer =
  a.short_short_integer__content
 
 meta "model_projection" function short_short_integer__ref_short_short_integer__content__projection
 
 meta "inline:no" function short_short_integer__ref_short_short_integer__content__projection
 
 val short_short_integer__havoc 
   (x : short_short_integer__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "short_short_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_short_integer__rep
 use        Standard__short_short_integer as Standard__short_short_integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__short_short_integer.short_short_integer) : int =
  (Standard__short_short_integer.short_short_integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__short_short_integer.short_short_integer, 
 predicate in_range = Standard__short_short_integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "short_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type short_integer =
  < range -32768 32767 >
 
 val constant first 
   : int
  ensures { result =  (( -32768) : int) }
 
 val constant last 
   : int
  ensures { result =  (32767 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = short_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type short_integer__ref =
  { mutable short_integer__content : short_integer }
 
 function short_integer__ref_short_integer__content__projection 
   (a : short_integer__ref) : short_integer =
  a.short_integer__content
 
 meta "model_projection" function short_integer__ref_short_integer__content__projection
 
 meta "inline:no" function short_integer__ref_short_integer__content__projection
 
 val short_integer__havoc 
   (x : short_integer__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "short_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_integer__rep
 use        Standard__short_integer as Standard__short_integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__short_integer.short_integer) : int =
  (Standard__short_integer.short_integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__short_integer.short_integer, 
 predicate in_range = Standard__short_integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer =
  < range -2147483648 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (( -2147483648) : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer__ref =
  { mutable integer__content : integer }
 
 function integer__ref_integer__content__projection 
   (a : integer__ref) : integer =
  a.integer__content
 
 meta "model_projection" function integer__ref_integer__content__projection
 
 meta "inline:no" function integer__ref_integer__content__projection
 
 val integer__havoc 
   (x : integer__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer__rep
 use        Standard__integer as Standard__integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__integer.integer) : int =
  (Standard__integer.integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__integer.integer, 
 predicate in_range = Standard__integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "long_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type long_integer =
  < range -2147483648 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (( -2147483648) : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = long_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type long_integer__ref =
  { mutable long_integer__content : long_integer }
 
 function long_integer__ref_long_integer__content__projection 
   (a : long_integer__ref) : long_integer =
  a.long_integer__content
 
 meta "model_projection" function long_integer__ref_long_integer__content__projection
 
 meta "inline:no" function long_integer__ref_long_integer__content__projection
 
 val long_integer__havoc 
   (x : long_integer__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "long_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_integer__rep
 use        Standard__long_integer as Standard__long_integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__long_integer.long_integer) : int =
  (Standard__long_integer.long_integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__long_integer.long_integer, 
 predicate in_range = Standard__long_integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "long_long_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_long_integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type long_long_integer =
  < range -9223372036854775808 9223372036854775807 >
 
 val constant first 
   : int
  ensures { result =  (( -9223372036854775808) : int) }
 
 val constant last 
   : int
  ensures { result =  (9223372036854775807 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = long_long_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type long_long_integer__ref =
  { mutable long_long_integer__content : long_long_integer }
 
 function long_long_integer__ref_long_long_integer__content__projection 
   (a : long_long_integer__ref) : long_long_integer =
  a.long_long_integer__content
 
 meta "model_projection" function long_long_integer__ref_long_long_integer__content__projection
 
 meta "inline:no" function long_long_integer__ref_long_long_integer__content__projection
 
 val long_long_integer__havoc 
   (x : long_long_integer__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "long_long_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_long_integer__rep
 use        Standard__long_long_integer as Standard__long_long_integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__long_long_integer.long_long_integer) : int =
  (Standard__long_long_integer.long_long_integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__long_long_integer.long_long_integer, 
 predicate in_range = Standard__long_long_integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "natural", created in Gnat2Why.Types.Translate_Type *)
module Standard__natural
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type natural =
  < range 0 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = natural, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type natural__ref =
  { mutable natural__content : natural }
 
 function natural__ref_natural__content__projection 
   (a : natural__ref) : natural =
  a.natural__content
 
 meta "model_projection" function natural__ref_natural__content__projection
 
 meta "inline:no" function natural__ref_natural__content__projection
 
 val natural__havoc 
   (x : natural__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "natural", created in Gnat2Why.Types.Translate_Type *)
module Standard__natural__rep
 use        Standard__natural as Standard__natural
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__natural.natural) : int =
  (Standard__natural.natural'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__natural.natural, 
 predicate in_range = Standard__natural.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "positive", created in Gnat2Why.Types.Translate_Type *)
module Standard__positive
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type positive =
  < range 1 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = positive, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type positive__ref =
  { mutable positive__content : positive }
 
 function positive__ref_positive__content__projection 
   (a : positive__ref) : positive =
  a.positive__content
 
 meta "model_projection" function positive__ref_positive__content__projection
 
 meta "inline:no" function positive__ref_positive__content__projection
 
 val positive__havoc 
   (x : positive__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "positive", created in Gnat2Why.Types.Translate_Type *)
module Standard__positive__rep
 use        Standard__positive as Standard__positive
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__positive.positive) : int =
  (Standard__positive.positive'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__positive.positive, 
 predicate in_range = Standard__positive.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "short_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_float
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type short_float 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = short_float, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type short_float__ref =
  { mutable short_float__content : short_float }
 
 function short_float__ref_short_float__content__projection 
   (a : short_float__ref) : short_float =
  a.short_float__content
 
 meta "model_projection" function short_float__ref_short_float__content__projection
 
 meta "inline:no" function short_float__ref_short_float__content__projection
 
 val short_float__havoc 
   (x : short_float__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "short_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_float__rep
 use        Standard__short_float as Standard__short_float
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Standard__short_float.short_float, 
 predicate in_range = Standard__short_float.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "float", created in Gnat2Why.Types.Translate_Type *)
module Standard__float
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type float__ 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = float__, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type float____ref =
  { mutable float____content : float__ }
 
 function float____ref_float____content__projection 
   (a : float____ref) : float__ =
  a.float____content
 
 meta "model_projection" function float____ref_float____content__projection
 
 meta "inline:no" function float____ref_float____content__projection
 
 val float____havoc 
   (x : float____ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "float", created in Gnat2Why.Types.Translate_Type *)
module Standard__float__rep
 use        Standard__float as Standard__float
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Standard__float.float__, 
 predicate in_range = Standard__float.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "long_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_float
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float64 as Float64

 type long_float 
 
 val constant first 
   : Float64.t
  ensures { result =  (Float64.neg (179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0:Float64.t)) }
 
 val constant last 
   : Float64.t
  ensures { result =  (179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0:Float64.t) }
 
 predicate in_range 
   (x : Float64.t) =
  (Float64.t'isFinite x)
 val in_range 
   (x : Float64.t) : bool
  ensures { result <-> in_range (x : Float64.t) }
 
 clone export "ada__model".Static_Float64 with axiom .,
 type t = long_float, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type long_float__ref =
  { mutable long_float__content : long_float }
 
 function long_float__ref_long_float__content__projection 
   (a : long_float__ref) : long_float =
  a.long_float__content
 
 meta "model_projection" function long_float__ref_long_float__content__projection
 
 meta "inline:no" function long_float__ref_long_float__content__projection
 
 val long_float__havoc 
   (x : long_float__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "long_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_float__rep
 use        Standard__long_float as Standard__long_float
 use        "_gnatprove_standard".Float64 as Float64
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float64 with axiom .,
 type t = Standard__long_float.long_float, 
 predicate in_range = Standard__long_float.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "character", created in Gnat2Why.Types.Translate_Type *)
module Standard__character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type character 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (255 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type character__ref =
  { mutable character__content : character }
 
 function character__ref_character__content__projection 
   (a : character__ref) : character =
  a.character__content
 
 meta "model_projection" function character__ref_character__content__projection
 
 meta "inline:no" function character__ref_character__content__projection
 
 val character__havoc 
   (x : character__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "character", created in Gnat2Why.Types.Translate_Type *)
module Standard__character__rep
 use        Standard__character as Standard__character
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__character.character, 
 predicate in_range = Standard__character.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "wide_character", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type wide_character 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (65535 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = wide_character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type wide_character__ref =
  { mutable wide_character__content : wide_character }
 
 function wide_character__ref_wide_character__content__projection 
   (a : wide_character__ref) : wide_character =
  a.wide_character__content
 
 meta "model_projection" function wide_character__ref_wide_character__content__projection
 
 meta "inline:no" function wide_character__ref_wide_character__content__projection
 
 val wide_character__havoc 
   (x : wide_character__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "wide_character", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_character__rep
 use        Standard__wide_character as Standard__wide_character
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__wide_character.wide_character, 
 predicate in_range = Standard__wide_character.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "wide_wide_character", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_wide_character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type wide_wide_character 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = wide_wide_character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type wide_wide_character__ref =
  { mutable wide_wide_character__content : wide_wide_character }
 
 function wide_wide_character__ref_wide_wide_character__content__projection 
   (a : wide_wide_character__ref) : wide_wide_character =
  a.wide_wide_character__content
 
 meta "model_projection" function wide_wide_character__ref_wide_wide_character__content__projection
 
 meta "inline:no" function wide_wide_character__ref_wide_wide_character__content__projection
 
 val wide_wide_character__havoc 
   (x : wide_wide_character__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "wide_wide_character", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_wide_character__rep
 use        Standard__wide_wide_character as Standard__wide_wide_character
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__wide_wide_character.wide_wide_character, 
 predicate in_range = Standard__wide_wide_character.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing the array theory associated to type "string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character
 use        Standard__character__rep as Standard__character__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 type component_type =
  Standard__character.character
 
 clone export "_gnatprove_standard".Array__1 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool =
  ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (forall temp___idx_91   : int.
   (if (( (a__first <= temp___idx_91) /\ (temp___idx_91 <= a__last) )) then (
    ((Standard__character__rep.to_rep (get a temp___idx_91)) = (Standard__character__rep.to_rep (get b ((b__first - a__first) + temp___idx_91))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   b__first   b__last   : int.
   ( ((bool_eq b b__first b__last a a__first a__last) = True) -> ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (forall temp___idx_91   : int.
    (if (( (a__first <= temp___idx_91) /\ (temp___idx_91 <= a__last) )) then (
     ((Standard__character__rep.to_rep (get a temp___idx_91)) = (Standard__character__rep.to_rep (get b ((b__first - a__first) + temp___idx_91))))) else true)) ) )))

end

(* Module for axiomatizing concatenation for the array theory associated to type "string", created in Why.Gen.Arrays.Declare_Concatenation_Symbols *)
module Array__Int__Standard__character__Concat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Array__Int__Standard__character as Array__Int__Standard__character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "_gnatprove_standard".Array__1__Concat with axiom .,
 type component_type = Array__Int__Standard__character.component_type, 
 type map = Array__Int__Standard__character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__character.get

end

(* Module for axiomatizing comparison for the array theory associated to type "string", created in Why.Gen.Arrays.Declare_Comparison_Symbols *)
module Array__Int__Standard__character_Comp
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character__rep as Standard__character__rep
 use        Array__Int__Standard__character as Array__Int__Standard__character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with axiom .,
 type component_type = Array__Int__Standard__character.component_type, 
 function to_rep = Standard__character__rep.to_rep, 
 type map = Array__Int__Standard__character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__character.get, 
 function bool_eq = Array__Int__Standard__character.bool_eq

end

(* Module for axiomatizing type "string", created in Gnat2Why.Types.Translate_Type *)
module Standard__string
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer
 use        Standard__positive as Standard__positive
 use        Standard__character as Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Standard__integer__rep as Standard__integer__rep

 type component_type =
  Standard__character.character
 
 function index_1_id 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with axiom .,
 type map = Array__Int__Standard__character.map, 
 function array_bool_eq = Array__Int__Standard__character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer__rep.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type string =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline:no" function to_array
 
 meta "model_projection" function first
 
 meta "inline:no" function first
 
 meta "model_projection" function last
 
 meta "inline:no" function last
 
 type string__ref =
  { mutable string__content : string }
 
 function string__ref_string__content__projection 
   (a : string__ref) : string =
  a.string__content
 
 meta "model_projection" function string__ref_string__content__projection
 
 meta "inline:no" function string__ref_string__content__projection
 
 val string__havoc 
   (x : string__ref) : unit
  writes {x}

end

(* Module defining to_string/of_string functions, created in Gnat2Why.Types.Translate_Type *)
module Standard_String__Img
 use        "int".Int
 use        Standard__string as Standard__string
 use        "_gnatprove_standard".Main
 use        "int".Int

 val function to_string 
   (x : Main.__image) (s : int) : Standard__string.string
 
 val function from_string 
   (x : Standard__string.string) : Main.__image
 
 axiom to_string__first :
  (forall x   : Main.__image.
  (forall s   : int [(to_string x s)].
   ((Standard__string.first (to_string x s)) = (1 : int))))
 
 axiom to_string__length :
  (forall x   : Main.__image.
  (forall s   : int [(to_string x s)].
   ( (s >= (0 : int)) -> ((Standard__string.length (to_string x s)) <= s) )))

end

(* Module for axiomatizing the array theory associated to type "wide_string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__wide_character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__wide_character as Standard__wide_character
 use        Standard__wide_character__rep as Standard__wide_character__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 type component_type =
  Standard__wide_character.wide_character
 
 clone export "_gnatprove_standard".Array__1 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool =
  ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (forall temp___idx_98   : int.
   (if (( (a__first <= temp___idx_98) /\ (temp___idx_98 <= a__last) )) then (
    ((Standard__wide_character__rep.to_rep (get a temp___idx_98)) = (Standard__wide_character__rep.to_rep (get b ((b__first - a__first) + temp___idx_98))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   b__first   b__last   : int.
   ( ((bool_eq b b__first b__last a a__first a__last) = True) -> ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (forall temp___idx_98   : int.
    (if (( (a__first <= temp___idx_98) /\ (temp___idx_98 <= a__last) )) then (
     ((Standard__wide_character__rep.to_rep (get a temp___idx_98)) = (Standard__wide_character__rep.to_rep (get b ((b__first - a__first) + temp___idx_98))))) else true)) ) )))

end

(* Module for axiomatizing concatenation for the array theory associated to type "wide_string", created in Why.Gen.Arrays.Declare_Concatenation_Symbols *)
module Array__Int__Standard__wide_character__Concat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Array__Int__Standard__wide_character as Array__Int__Standard__wide_character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "_gnatprove_standard".Array__1__Concat with axiom .,
 type component_type = Array__Int__Standard__wide_character.component_type, 
 type map = Array__Int__Standard__wide_character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__wide_character.get

end

(* Module for axiomatizing comparison for the array theory associated to type "wide_string", created in Why.Gen.Arrays.Declare_Comparison_Symbols *)
module Array__Int__Standard__wide_character_Comp
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__wide_character__rep as Standard__wide_character__rep
 use        Array__Int__Standard__wide_character as Array__Int__Standard__wide_character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with axiom .,
 type component_type = Array__Int__Standard__wide_character.component_type, 
 function to_rep = Standard__wide_character__rep.to_rep, 
 type map = Array__Int__Standard__wide_character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__wide_character.get, 
 function bool_eq = Array__Int__Standard__wide_character.bool_eq

end

(* Module for axiomatizing type "wide_string", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_string
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer
 use        Standard__positive as Standard__positive
 use        Standard__wide_character as Standard__wide_character
 use        Standard__integer__rep as Standard__integer__rep
 use        Array__Int__Standard__wide_character as Array__Int__Standard__wide_character

 type component_type =
  Standard__wide_character.wide_character
 
 function index_1_id 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with axiom .,
 type map = Array__Int__Standard__wide_character.map, 
 function array_bool_eq = Array__Int__Standard__wide_character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer__rep.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type wide_string =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline:no" function to_array
 
 meta "model_projection" function first
 
 meta "inline:no" function first
 
 meta "model_projection" function last
 
 meta "inline:no" function last
 
 type wide_string__ref =
  { mutable wide_string__content : wide_string }
 
 function wide_string__ref_wide_string__content__projection 
   (a : wide_string__ref) : wide_string =
  a.wide_string__content
 
 meta "model_projection" function wide_string__ref_wide_string__content__projection
 
 meta "inline:no" function wide_string__ref_wide_string__content__projection
 
 val wide_string__havoc 
   (x : wide_string__ref) : unit
  writes {x}

end

(* Module for axiomatizing the array theory associated to type "wide_wide_string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__wide_wide_character
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__wide_wide_character as Standard__wide_wide_character
 use        Standard__wide_wide_character__rep as Standard__wide_wide_character__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 type component_type =
  Standard__wide_wide_character.wide_wide_character
 
 clone export "_gnatprove_standard".Array__1 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool =
  ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (forall temp___idx_105   : int.
   (if (( (a__first <= temp___idx_105) /\ (temp___idx_105 <= a__last) )) then (
    ((Standard__wide_wide_character__rep.to_rep (get a temp___idx_105)) = (Standard__wide_wide_character__rep.to_rep (get b ((b__first - a__first) + temp___idx_105))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   b__first   b__last   : int.
   ( ((bool_eq b b__first b__last a a__first a__last) = True) -> ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (forall temp___idx_105   : int.
    (if (( (a__first <= temp___idx_105) /\ (temp___idx_105 <= a__last) )) then (
     ((Standard__wide_wide_character__rep.to_rep (get a temp___idx_105)) = (Standard__wide_wide_character__rep.to_rep (get b ((b__first - a__first) + temp___idx_105))))) else true)) ) )))

end

(* Module for axiomatizing concatenation for the array theory associated to type "wide_wide_string", created in Why.Gen.Arrays.Declare_Concatenation_Symbols *)
module Array__Int__Standard__wide_wide_character__Concat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Array__Int__Standard__wide_wide_character as Array__Int__Standard__wide_wide_character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "_gnatprove_standard".Array__1__Concat with axiom .,
 type component_type = Array__Int__Standard__wide_wide_character.component_type, 
 type map = Array__Int__Standard__wide_wide_character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__wide_wide_character.get

end

(* Module for axiomatizing comparison for the array theory associated to type "wide_wide_string", created in Why.Gen.Arrays.Declare_Comparison_Symbols *)
module Array__Int__Standard__wide_wide_character_Comp
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__wide_wide_character__rep as Standard__wide_wide_character__rep
 use        Array__Int__Standard__wide_wide_character as Array__Int__Standard__wide_wide_character

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with axiom .,
 type component_type = Array__Int__Standard__wide_wide_character.component_type, 
 function to_rep = Standard__wide_wide_character__rep.to_rep, 
 type map = Array__Int__Standard__wide_wide_character.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Standard__wide_wide_character.get, 
 function bool_eq = Array__Int__Standard__wide_wide_character.bool_eq

end

(* Module for axiomatizing type "wide_wide_string", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_wide_string
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer
 use        Standard__positive as Standard__positive
 use        Standard__wide_wide_character as Standard__wide_wide_character
 use        Standard__integer__rep as Standard__integer__rep
 use        Array__Int__Standard__wide_wide_character as Array__Int__Standard__wide_wide_character

 type component_type =
  Standard__wide_wide_character.wide_wide_character
 
 function index_1_id 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with axiom .,
 type map = Array__Int__Standard__wide_wide_character.map, 
 function array_bool_eq = Array__Int__Standard__wide_wide_character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer__rep.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type wide_wide_string =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline:no" function to_array
 
 meta "model_projection" function first
 
 meta "inline:no" function first
 
 meta "model_projection" function last
 
 meta "inline:no" function last
 
 type wide_wide_string__ref =
  { mutable wide_wide_string__content : wide_wide_string }
 
 function wide_wide_string__ref_wide_wide_string__content__projection 
   (a : wide_wide_string__ref) : wide_wide_string =
  a.wide_wide_string__content
 
 meta "model_projection" function wide_wide_string__ref_wide_wide_string__content__projection
 
 meta "inline:no" function wide_wide_string__ref_wide_wide_string__content__projection
 
 val wide_wide_string__havoc 
   (x : wide_wide_string__ref) : unit
  writes {x}

end

(* Module for fixed-point operation for type at system.ads:1, created in Why.Gen.Scalars.Create_Fixed_Point_Theory_If_Needed *)
module Fixed_Point__1_1000000000
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 function num_small 
   : int =
  (1 : int)
 
 function den_small 
   : int =
  (1000000000 : int)
 
 clone export "ada__model".Fixed_Point_Rep with axiom .,
 function num_small = num_small, 
 function den_small = den_small

end

(* Module for axiomatizing type "duration", created in Gnat2Why.Types.Translate_Type *)
module Standard__duration
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main

 type duration 
 
 val constant num_small 
   : Main.__fixed
  ensures { result =  (1 : int) }
 
 val constant den_small 
   : Main.__fixed
  ensures { result =  (1000000000 : int) }
 
 val constant first 
   : Main.__fixed
  ensures { result =  ( ( -9223372036854775808 ) : int ) }
 
 val constant last 
   : Main.__fixed
  ensures { result =  ( 9223372036854775807 : int ) }
 
 predicate in_range 
   (x : Main.__fixed) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : Main.__fixed) : bool
  ensures { result <-> in_range (x : Main.__fixed) }
 
 clone export "ada__model".Static_Fixed_Point with axiom .,
 type t = duration, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type duration__ref =
  { mutable duration__content : duration }
 
 function duration__ref_duration__content__projection 
   (a : duration__ref) : duration =
  a.duration__content
 
 meta "model_projection" function duration__ref_duration__content__projection
 
 meta "inline:no" function duration__ref_duration__content__projection
 
 val duration__havoc 
   (x : duration__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "duration", created in Gnat2Why.Types.Translate_Type *)
module Standard__duration__rep
 use        Standard__duration as Standard__duration
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Fixed with axiom .,
 type t = Standard__duration.duration, 
 predicate in_range = Standard__duration.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "integer_8", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_8
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer_8 =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer_8, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer_8__ref =
  { mutable integer_8__content : integer_8 }
 
 function integer_8__ref_integer_8__content__projection 
   (a : integer_8__ref) : integer_8 =
  a.integer_8__content
 
 meta "model_projection" function integer_8__ref_integer_8__content__projection
 
 meta "inline:no" function integer_8__ref_integer_8__content__projection
 
 val integer_8__havoc 
   (x : integer_8__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "integer_8", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_8__rep
 use        Standard__integer_8 as Standard__integer_8
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__integer_8.integer_8) : int =
  (Standard__integer_8.integer_8'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__integer_8.integer_8, 
 predicate in_range = Standard__integer_8.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "integer_16", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_16
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer_16 =
  < range -32768 32767 >
 
 val constant first 
   : int
  ensures { result =  (( -32768) : int) }
 
 val constant last 
   : int
  ensures { result =  (32767 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer_16, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer_16__ref =
  { mutable integer_16__content : integer_16 }
 
 function integer_16__ref_integer_16__content__projection 
   (a : integer_16__ref) : integer_16 =
  a.integer_16__content
 
 meta "model_projection" function integer_16__ref_integer_16__content__projection
 
 meta "inline:no" function integer_16__ref_integer_16__content__projection
 
 val integer_16__havoc 
   (x : integer_16__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "integer_16", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_16__rep
 use        Standard__integer_16 as Standard__integer_16
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__integer_16.integer_16) : int =
  (Standard__integer_16.integer_16'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__integer_16.integer_16, 
 predicate in_range = Standard__integer_16.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "integer_32", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_32
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer_32 =
  < range -2147483648 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (( -2147483648) : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer_32, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer_32__ref =
  { mutable integer_32__content : integer_32 }
 
 function integer_32__ref_integer_32__content__projection 
   (a : integer_32__ref) : integer_32 =
  a.integer_32__content
 
 meta "model_projection" function integer_32__ref_integer_32__content__projection
 
 meta "inline:no" function integer_32__ref_integer_32__content__projection
 
 val integer_32__havoc 
   (x : integer_32__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "integer_32", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_32__rep
 use        Standard__integer_32 as Standard__integer_32
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__integer_32.integer_32) : int =
  (Standard__integer_32.integer_32'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__integer_32.integer_32, 
 predicate in_range = Standard__integer_32.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "integer_64", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_64
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type integer_64 =
  < range -9223372036854775808 9223372036854775807 >
 
 val constant first 
   : int
  ensures { result =  (( -9223372036854775808) : int) }
 
 val constant last 
   : int
  ensures { result =  (9223372036854775807 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = integer_64, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type integer_64__ref =
  { mutable integer_64__content : integer_64 }
 
 function integer_64__ref_integer_64__content__projection 
   (a : integer_64__ref) : integer_64 =
  a.integer_64__content
 
 meta "model_projection" function integer_64__ref_integer_64__content__projection
 
 meta "inline:no" function integer_64__ref_integer_64__content__projection
 
 val integer_64__havoc 
   (x : integer_64__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "integer_64", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_64__rep
 use        Standard__integer_64 as Standard__integer_64
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__integer_64.integer_64) : int =
  (Standard__integer_64.integer_64'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__integer_64.integer_64, 
 predicate in_range = Standard__integer_64.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "universal_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__universal_integer
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type universal_integer =
  < range -9223372036854775808 9223372036854775807 >
 
 val constant first 
   : int
  ensures { result =  (( -9223372036854775808) : int) }
 
 val constant last 
   : int
  ensures { result =  (9223372036854775807 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = universal_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type universal_integer__ref =
  { mutable universal_integer__content : universal_integer }
 
 function universal_integer__ref_universal_integer__content__projection 
   (a : universal_integer__ref) : universal_integer =
  a.universal_integer__content
 
 meta "model_projection" function universal_integer__ref_universal_integer__content__projection
 
 meta "inline:no" function universal_integer__ref_universal_integer__content__projection
 
 val universal_integer__havoc 
   (x : universal_integer__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "universal_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__universal_integer__rep
 use        Standard__universal_integer as Standard__universal_integer
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Standard__universal_integer.universal_integer) : int =
  (Standard__universal_integer.universal_integer'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Standard__universal_integer.universal_integer, 
 predicate in_range = Standard__universal_integer.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "carriageslot" defined at cw.ads:5, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriageslot
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type carriageslot 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (1 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = carriageslot, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type carriageslot__ref =
  { mutable carriageslot__content : carriageslot }
 
 function carriageslot__ref_carriageslot__content__projection 
   (a : carriageslot__ref) : carriageslot =
  a.carriageslot__content
 
 meta "model_projection" function carriageslot__ref_carriageslot__content__projection
 
 meta "inline:no" function carriageslot__ref_carriageslot__content__projection
 
 val carriageslot__havoc 
   (x : carriageslot__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "carriageslot" defined at cw.ads:5, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriageslot__rep
 use        Cw__carriageslot as Cw__carriageslot
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__carriageslot.carriageslot, 
 predicate in_range = Cw__carriageslot.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "moving" defined at cw.ads:6, created in Gnat2Why.Types.Translate_Type *)
module Cw__moving
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type moving 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (2 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = moving, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type moving__ref =
  { mutable moving__content : moving }
 
 function moving__ref_moving__content__projection 
   (a : moving__ref) : moving =
  a.moving__content
 
 meta "model_projection" function moving__ref_moving__content__projection
 
 meta "inline:no" function moving__ref_moving__content__projection
 
 val moving__havoc 
   (x : moving__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "moving" defined at cw.ads:6, created in Gnat2Why.Types.Translate_Type *)
module Cw__moving__rep
 use        Cw__moving as Cw__moving
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__moving.moving, 
 predicate in_range = Cw__moving.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "rod" defined at cw.ads:8, created in Gnat2Why.Types.Translate_Type *)
module Cw__rod
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type rod 
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (1 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = rod, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type rod__ref =
  { mutable rod__content : rod }
 
 function rod__ref_rod__content__projection 
   (a : rod__ref) : rod =
  a.rod__content
 
 meta "model_projection" function rod__ref_rod__content__projection
 
 meta "inline:no" function rod__ref_rod__content__projection
 
 val rod__havoc 
   (x : rod__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "rod" defined at cw.ads:8, created in Gnat2Why.Types.Translate_Type *)
module Cw__rod__rep
 use        Cw__rod as Cw__rod
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__rod.rod, 
 predicate in_range = Cw__rod.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TenergyB" defined at cw.ads:10, created in Gnat2Why.Types.Translate_Type *)
module Cw__TenergyB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type tenergyB 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = tenergyB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tenergyB__ref =
  { mutable tenergyB__content : tenergyB }
 
 function tenergyB__ref_tenergyB__content__projection 
   (a : tenergyB__ref) : tenergyB =
  a.tenergyB__content
 
 meta "model_projection" function tenergyB__ref_tenergyB__content__projection
 
 meta "inline:no" function tenergyB__ref_tenergyB__content__projection
 
 val tenergyB__havoc 
   (x : tenergyB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TenergyB" defined at cw.ads:10, created in Gnat2Why.Types.Translate_Type *)
module Cw__TenergyB__rep
 use        Cw__TenergyB as Cw__TenergyB
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__TenergyB.tenergyB, 
 predicate in_range = Cw__TenergyB.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "energy" defined at cw.ads:10, created in Gnat2Why.Types.Translate_Type *)
module Cw__energy
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type energy 
 
 val constant first 
   : Float32.t
  ensures { result =  (0.0E-1:Float32.t) }
 
 val constant last 
   : Float32.t
  ensures { result =  (100.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  ( (Float32.t'isFinite x) && ( (Float32.le first x) /\ (Float32.le x last) ) )
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = energy, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type energy__ref =
  { mutable energy__content : energy }
 
 function energy__ref_energy__content__projection 
   (a : energy__ref) : energy =
  a.energy__content
 
 meta "model_projection" function energy__ref_energy__content__projection
 
 meta "inline:no" function energy__ref_energy__content__projection
 
 val energy__havoc 
   (x : energy__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "energy" defined at cw.ads:10, created in Gnat2Why.Types.Translate_Type *)
module Cw__energy__rep
 use        Cw__energy as Cw__energy
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__energy.energy, 
 predicate in_range = Cw__energy.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TheatB" defined at cw.ads:11, created in Gnat2Why.Types.Translate_Type *)
module Cw__TheatB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type theatB 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = theatB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type theatB__ref =
  { mutable theatB__content : theatB }
 
 function theatB__ref_theatB__content__projection 
   (a : theatB__ref) : theatB =
  a.theatB__content
 
 meta "model_projection" function theatB__ref_theatB__content__projection
 
 meta "inline:no" function theatB__ref_theatB__content__projection
 
 val theatB__havoc 
   (x : theatB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TheatB" defined at cw.ads:11, created in Gnat2Why.Types.Translate_Type *)
module Cw__TheatB__rep
 use        Cw__TheatB as Cw__TheatB
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__TheatB.theatB, 
 predicate in_range = Cw__TheatB.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "heat" defined at cw.ads:11, created in Gnat2Why.Types.Translate_Type *)
module Cw__heat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type heat 
 
 val constant first 
   : Float32.t
  ensures { result =  (0.0E-1:Float32.t) }
 
 val constant last 
   : Float32.t
  ensures { result =  (500.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  ( (Float32.t'isFinite x) && ( (Float32.le first x) /\ (Float32.le x last) ) )
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = heat, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type heat__ref =
  { mutable heat__content : heat }
 
 function heat__ref_heat__content__projection 
   (a : heat__ref) : heat =
  a.heat__content
 
 meta "model_projection" function heat__ref_heat__content__projection
 
 meta "inline:no" function heat__ref_heat__content__projection
 
 val heat__havoc 
   (x : heat__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "heat" defined at cw.ads:11, created in Gnat2Why.Types.Translate_Type *)
module Cw__heat__rep
 use        Cw__heat as Cw__heat
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__heat.heat, 
 predicate in_range = Cw__heat.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TwaterB" defined at cw.ads:12, created in Gnat2Why.Types.Translate_Type *)
module Cw__TwaterB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type twaterB 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = twaterB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type twaterB__ref =
  { mutable twaterB__content : twaterB }
 
 function twaterB__ref_twaterB__content__projection 
   (a : twaterB__ref) : twaterB =
  a.twaterB__content
 
 meta "model_projection" function twaterB__ref_twaterB__content__projection
 
 meta "inline:no" function twaterB__ref_twaterB__content__projection
 
 val twaterB__havoc 
   (x : twaterB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TwaterB" defined at cw.ads:12, created in Gnat2Why.Types.Translate_Type *)
module Cw__TwaterB__rep
 use        Cw__TwaterB as Cw__TwaterB
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__TwaterB.twaterB, 
 predicate in_range = Cw__TwaterB.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "water" defined at cw.ads:12, created in Gnat2Why.Types.Translate_Type *)
module Cw__water
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type water 
 
 val constant first 
   : Float32.t
  ensures { result =  (0.0E-1:Float32.t) }
 
 val constant last 
   : Float32.t
  ensures { result =  (100.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  ( (Float32.t'isFinite x) && ( (Float32.le first x) /\ (Float32.le x last) ) )
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = water, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type water__ref =
  { mutable water__content : water }
 
 function water__ref_water__content__projection 
   (a : water__ref) : water =
  a.water__content
 
 meta "model_projection" function water__ref_water__content__projection
 
 meta "inline:no" function water__ref_water__content__projection
 
 val water__havoc 
   (x : water__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "water" defined at cw.ads:12, created in Gnat2Why.Types.Translate_Type *)
module Cw__water__rep
 use        Cw__water as Cw__water
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__water.water, 
 predicate in_range = Cw__water.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TspeedB" defined at cw.ads:13, created in Gnat2Why.Types.Translate_Type *)
module Cw__TspeedB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type tspeedB 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = tspeedB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tspeedB__ref =
  { mutable tspeedB__content : tspeedB }
 
 function tspeedB__ref_tspeedB__content__projection 
   (a : tspeedB__ref) : tspeedB =
  a.tspeedB__content
 
 meta "model_projection" function tspeedB__ref_tspeedB__content__projection
 
 meta "inline:no" function tspeedB__ref_tspeedB__content__projection
 
 val tspeedB__havoc 
   (x : tspeedB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TspeedB" defined at cw.ads:13, created in Gnat2Why.Types.Translate_Type *)
module Cw__TspeedB__rep
 use        Cw__TspeedB as Cw__TspeedB
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__TspeedB.tspeedB, 
 predicate in_range = Cw__TspeedB.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "speed" defined at cw.ads:13, created in Gnat2Why.Types.Translate_Type *)
module Cw__speed
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type speed 
 
 val constant first 
   : Float32.t
  ensures { result =  (0.0E-1:Float32.t) }
 
 val constant last 
   : Float32.t
  ensures { result =  (500.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  ( (Float32.t'isFinite x) && ( (Float32.le first x) /\ (Float32.le x last) ) )
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = speed, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type speed__ref =
  { mutable speed__content : speed }
 
 function speed__ref_speed__content__projection 
   (a : speed__ref) : speed =
  a.speed__content
 
 meta "model_projection" function speed__ref_speed__content__projection
 
 meta "inline:no" function speed__ref_speed__content__projection
 
 val speed__havoc 
   (x : speed__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "speed" defined at cw.ads:13, created in Gnat2Why.Types.Translate_Type *)
module Cw__speed__rep
 use        Cw__speed as Cw__speed
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Cw__speed.speed, 
 predicate in_range = Cw__speed.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TcarriagerangeB" defined at cw.ads:15, created in Gnat2Why.Types.Translate_Type *)
module Cw__TcarriagerangeB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type tcarriagerangeB =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = tcarriagerangeB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tcarriagerangeB__ref =
  { mutable tcarriagerangeB__content : tcarriagerangeB }
 
 function tcarriagerangeB__ref_tcarriagerangeB__content__projection 
   (a : tcarriagerangeB__ref) : tcarriagerangeB =
  a.tcarriagerangeB__content
 
 meta "model_projection" function tcarriagerangeB__ref_tcarriagerangeB__content__projection
 
 meta "inline:no" function tcarriagerangeB__ref_tcarriagerangeB__content__projection
 
 val tcarriagerangeB__havoc 
   (x : tcarriagerangeB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TcarriagerangeB" defined at cw.ads:15, created in Gnat2Why.Types.Translate_Type *)
module Cw__TcarriagerangeB__rep
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__TcarriagerangeB.tcarriagerangeB) : int =
  (Cw__TcarriagerangeB.tcarriagerangeB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__TcarriagerangeB.tcarriagerangeB, 
 predicate in_range = Cw__TcarriagerangeB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "carriagerange" defined at cw.ads:15, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriagerange
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type carriagerange =
  < range 0 10 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (10 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = carriagerange, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type carriagerange__ref =
  { mutable carriagerange__content : carriagerange }
 
 function carriagerange__ref_carriagerange__content__projection 
   (a : carriagerange__ref) : carriagerange =
  a.carriagerange__content
 
 meta "model_projection" function carriagerange__ref_carriagerange__content__projection
 
 meta "inline:no" function carriagerange__ref_carriagerange__content__projection
 
 val carriagerange__havoc 
   (x : carriagerange__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "carriagerange" defined at cw.ads:15, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriagerange__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__carriagerange.carriagerange) : int =
  (Cw__carriagerange.carriagerange'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__carriagerange.carriagerange, 
 predicate in_range = Cw__carriagerange.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TcarriagecounterB" defined at cw.ads:16, created in Gnat2Why.Types.Translate_Type *)
module Cw__TcarriagecounterB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type tcarriagecounterB =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = tcarriagecounterB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tcarriagecounterB__ref =
  { mutable tcarriagecounterB__content : tcarriagecounterB }
 
 function tcarriagecounterB__ref_tcarriagecounterB__content__projection 
   (a : tcarriagecounterB__ref) : tcarriagecounterB =
  a.tcarriagecounterB__content
 
 meta "model_projection" function tcarriagecounterB__ref_tcarriagecounterB__content__projection
 
 meta "inline:no" function tcarriagecounterB__ref_tcarriagecounterB__content__projection
 
 val tcarriagecounterB__havoc 
   (x : tcarriagecounterB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TcarriagecounterB" defined at cw.ads:16, created in Gnat2Why.Types.Translate_Type *)
module Cw__TcarriagecounterB__rep
 use        Cw__TcarriagecounterB as Cw__TcarriagecounterB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__TcarriagecounterB.tcarriagecounterB) : int =
  (Cw__TcarriagecounterB.tcarriagecounterB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__TcarriagecounterB.tcarriagecounterB, 
 predicate in_range = Cw__TcarriagecounterB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "carriagecounter" defined at cw.ads:16, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriagecounter
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type carriagecounter =
  < range 0 11 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (11 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = carriagecounter, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type carriagecounter__ref =
  { mutable carriagecounter__content : carriagecounter }
 
 function carriagecounter__ref_carriagecounter__content__projection 
   (a : carriagecounter__ref) : carriagecounter =
  a.carriagecounter__content
 
 meta "model_projection" function carriagecounter__ref_carriagecounter__content__projection
 
 meta "inline:no" function carriagecounter__ref_carriagecounter__content__projection
 
 val carriagecounter__havoc 
   (x : carriagecounter__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "carriagecounter" defined at cw.ads:16, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriagecounter__rep
 use        Cw__carriagecounter as Cw__carriagecounter
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__carriagecounter.carriagecounter) : int =
  (Cw__carriagecounter.carriagecounter'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__carriagecounter.carriagecounter, 
 predicate in_range = Cw__carriagecounter.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TrodrangeB" defined at cw.ads:17, created in Gnat2Why.Types.Translate_Type *)
module Cw__TrodrangeB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type trodrangeB =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = trodrangeB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type trodrangeB__ref =
  { mutable trodrangeB__content : trodrangeB }
 
 function trodrangeB__ref_trodrangeB__content__projection 
   (a : trodrangeB__ref) : trodrangeB =
  a.trodrangeB__content
 
 meta "model_projection" function trodrangeB__ref_trodrangeB__content__projection
 
 meta "inline:no" function trodrangeB__ref_trodrangeB__content__projection
 
 val trodrangeB__havoc 
   (x : trodrangeB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TrodrangeB" defined at cw.ads:17, created in Gnat2Why.Types.Translate_Type *)
module Cw__TrodrangeB__rep
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__TrodrangeB.trodrangeB) : int =
  (Cw__TrodrangeB.trodrangeB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__TrodrangeB.trodrangeB, 
 predicate in_range = Cw__TrodrangeB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "rodrange" defined at cw.ads:17, created in Gnat2Why.Types.Translate_Type *)
module Cw__rodrange
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type rodrange =
  < range 0 4 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (4 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = rodrange, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type rodrange__ref =
  { mutable rodrange__content : rodrange }
 
 function rodrange__ref_rodrange__content__projection 
   (a : rodrange__ref) : rodrange =
  a.rodrange__content
 
 meta "model_projection" function rodrange__ref_rodrange__content__projection
 
 meta "inline:no" function rodrange__ref_rodrange__content__projection
 
 val rodrange__havoc 
   (x : rodrange__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "rodrange" defined at cw.ads:17, created in Gnat2Why.Types.Translate_Type *)
module Cw__rodrange__rep
 use        Cw__rodrange as Cw__rodrange
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__rodrange.rodrange) : int =
  (Cw__rodrange.rodrange'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__rodrange.rodrange, 
 predicate in_range = Cw__rodrange.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TrodcounterB" defined at cw.ads:18, created in Gnat2Why.Types.Translate_Type *)
module Cw__TrodcounterB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type trodcounterB =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = trodcounterB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type trodcounterB__ref =
  { mutable trodcounterB__content : trodcounterB }
 
 function trodcounterB__ref_trodcounterB__content__projection 
   (a : trodcounterB__ref) : trodcounterB =
  a.trodcounterB__content
 
 meta "model_projection" function trodcounterB__ref_trodcounterB__content__projection
 
 meta "inline:no" function trodcounterB__ref_trodcounterB__content__projection
 
 val trodcounterB__havoc 
   (x : trodcounterB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TrodcounterB" defined at cw.ads:18, created in Gnat2Why.Types.Translate_Type *)
module Cw__TrodcounterB__rep
 use        Cw__TrodcounterB as Cw__TrodcounterB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__TrodcounterB.trodcounterB) : int =
  (Cw__TrodcounterB.trodcounterB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__TrodcounterB.trodcounterB, 
 predicate in_range = Cw__TrodcounterB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "rodcounter" defined at cw.ads:18, created in Gnat2Why.Types.Translate_Type *)
module Cw__rodcounter
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type rodcounter =
  < range 0 5 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (5 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = rodcounter, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type rodcounter__ref =
  { mutable rodcounter__content : rodcounter }
 
 function rodcounter__ref_rodcounter__content__projection 
   (a : rodcounter__ref) : rodcounter =
  a.rodcounter__content
 
 meta "model_projection" function rodcounter__ref_rodcounter__content__projection
 
 meta "inline:no" function rodcounter__ref_rodcounter__content__projection
 
 val rodcounter__havoc 
   (x : rodcounter__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "rodcounter" defined at cw.ads:18, created in Gnat2Why.Types.Translate_Type *)
module Cw__rodcounter__rep
 use        Cw__rodcounter as Cw__rodcounter
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__rodcounter.rodcounter) : int =
  (Cw__rodcounter.rodcounter'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__rodcounter.rodcounter, 
 predicate in_range = Cw__rodcounter.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TincreaserrangeB" defined at cw.ads:19, created in Gnat2Why.Types.Translate_Type *)
module Cw__TincreaserrangeB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type tincreaserrangeB =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = tincreaserrangeB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tincreaserrangeB__ref =
  { mutable tincreaserrangeB__content : tincreaserrangeB }
 
 function tincreaserrangeB__ref_tincreaserrangeB__content__projection 
   (a : tincreaserrangeB__ref) : tincreaserrangeB =
  a.tincreaserrangeB__content
 
 meta "model_projection" function tincreaserrangeB__ref_tincreaserrangeB__content__projection
 
 meta "inline:no" function tincreaserrangeB__ref_tincreaserrangeB__content__projection
 
 val tincreaserrangeB__havoc 
   (x : tincreaserrangeB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TincreaserrangeB" defined at cw.ads:19, created in Gnat2Why.Types.Translate_Type *)
module Cw__TincreaserrangeB__rep
 use        Cw__TincreaserrangeB as Cw__TincreaserrangeB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__TincreaserrangeB.tincreaserrangeB) : int =
  (Cw__TincreaserrangeB.tincreaserrangeB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__TincreaserrangeB.tincreaserrangeB, 
 predicate in_range = Cw__TincreaserrangeB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "increaserrange" defined at cw.ads:19, created in Gnat2Why.Types.Translate_Type *)
module Cw__increaserrange
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type increaserrange =
  < range 0 100 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (100 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = increaserrange, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type increaserrange__ref =
  { mutable increaserrange__content : increaserrange }
 
 function increaserrange__ref_increaserrange__content__projection 
   (a : increaserrange__ref) : increaserrange =
  a.increaserrange__content
 
 meta "model_projection" function increaserrange__ref_increaserrange__content__projection
 
 meta "inline:no" function increaserrange__ref_increaserrange__content__projection
 
 val increaserrange__havoc 
   (x : increaserrange__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "increaserrange" defined at cw.ads:19, created in Gnat2Why.Types.Translate_Type *)
module Cw__increaserrange__rep
 use        Cw__increaserrange as Cw__increaserrange
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__increaserrange.increaserrange) : int =
  (Cw__increaserrange.increaserrange'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__increaserrange.increaserrange, 
 predicate in_range = Cw__increaserrange.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "TdepleterrangeB" defined at cw.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Cw__TdepleterrangeB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type tdepleterrangeB =
  < range -128 127 >
 
 val constant first 
   : int
  ensures { result =  (( -128) : int) }
 
 val constant last 
   : int
  ensures { result =  (127 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = tdepleterrangeB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tdepleterrangeB__ref =
  { mutable tdepleterrangeB__content : tdepleterrangeB }
 
 function tdepleterrangeB__ref_tdepleterrangeB__content__projection 
   (a : tdepleterrangeB__ref) : tdepleterrangeB =
  a.tdepleterrangeB__content
 
 meta "model_projection" function tdepleterrangeB__ref_tdepleterrangeB__content__projection
 
 meta "inline:no" function tdepleterrangeB__ref_tdepleterrangeB__content__projection
 
 val tdepleterrangeB__havoc 
   (x : tdepleterrangeB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TdepleterrangeB" defined at cw.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Cw__TdepleterrangeB__rep
 use        Cw__TdepleterrangeB as Cw__TdepleterrangeB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__TdepleterrangeB.tdepleterrangeB) : int =
  (Cw__TdepleterrangeB.tdepleterrangeB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__TdepleterrangeB.tdepleterrangeB, 
 predicate in_range = Cw__TdepleterrangeB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "depleterrange" defined at cw.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Cw__depleterrange
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type depleterrange =
  < range 0 15 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (15 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = depleterrange, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type depleterrange__ref =
  { mutable depleterrange__content : depleterrange }
 
 function depleterrange__ref_depleterrange__content__projection 
   (a : depleterrange__ref) : depleterrange =
  a.depleterrange__content
 
 meta "model_projection" function depleterrange__ref_depleterrange__content__projection
 
 meta "inline:no" function depleterrange__ref_depleterrange__content__projection
 
 val depleterrange__havoc 
   (x : depleterrange__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "depleterrange" defined at cw.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Cw__depleterrange__rep
 use        Cw__depleterrange as Cw__depleterrange
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Cw__depleterrange.depleterrange) : int =
  (Cw__depleterrange.depleterrange'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Cw__depleterrange.depleterrange, 
 predicate in_range = Cw__depleterrange.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing the array theory associated to type "TcarriagearrB" defined at cw.ads:22, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Cw__carriageslot
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 type component_type =
  Cw__carriageslot.carriageslot
 
 clone export "_gnatprove_standard".Array__1 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool =
  ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (forall temp___idx_154   : int.
   (if (( (a__first <= temp___idx_154) /\ (temp___idx_154 <= a__last) )) then (
    ((Cw__carriageslot__rep.to_rep (get a temp___idx_154)) = (Cw__carriageslot__rep.to_rep (get b ((b__first - a__first) + temp___idx_154))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   b__first   b__last   : int.
   ( ((bool_eq b b__first b__last a a__first a__last) = True) -> ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (forall temp___idx_154   : int.
    (if (( (a__first <= temp___idx_154) /\ (temp___idx_154 <= a__last) )) then (
     ((Cw__carriageslot__rep.to_rep (get a temp___idx_154)) = (Cw__carriageslot__rep.to_rep (get b ((b__first - a__first) + temp___idx_154))))) else true)) ) )))

end

(* Module for axiomatizing concatenation for the array theory associated to type "TcarriagearrB" defined at cw.ads:22, created in Why.Gen.Arrays.Declare_Concatenation_Symbols *)
module Array__Int__Cw__carriageslot__Concat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "_gnatprove_standard".Array__1__Concat with axiom .,
 type component_type = Array__Int__Cw__carriageslot.component_type, 
 type map = Array__Int__Cw__carriageslot.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Cw__carriageslot.get

end

(* Module for axiomatizing comparison for the array theory associated to type "TcarriagearrB" defined at cw.ads:22, created in Why.Gen.Arrays.Declare_Comparison_Symbols *)
module Array__Int__Cw__carriageslot_Comp
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with axiom .,
 type component_type = Array__Int__Cw__carriageslot.component_type, 
 function to_rep = Cw__carriageslot__rep.to_rep, 
 type map = Array__Int__Cw__carriageslot.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Cw__carriageslot.get, 
 function bool_eq = Array__Int__Cw__carriageslot.bool_eq

end

(* Module for axiomatizing type "TcarriagearrB" defined at cw.ads:22, created in Gnat2Why.Types.Translate_Type *)
module Cw__TcarriagearrB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        Cw__TcarriagerangeB__rep as Cw__TcarriagerangeB__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 type component_type =
  Cw__carriageslot.carriageslot
 
 function index_1_id 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with axiom .,
 type map = Array__Int__Cw__carriageslot.map, 
 function array_bool_eq = Array__Int__Cw__carriageslot.bool_eq, 
 type index_base_type = Cw__TcarriagerangeB.tcarriagerangeB, 
 type index_rep_type = int, 
 function to_rep = Cw__TcarriagerangeB__rep.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Cw__TcarriagerangeB.in_range, 
 predicate index_dynamic_property = Cw__carriagerange.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type tcarriagearrB =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline:no" function to_array
 
 meta "model_projection" function first
 
 meta "inline:no" function first
 
 meta "model_projection" function last
 
 meta "inline:no" function last
 
 type tcarriagearrB__ref =
  { mutable tcarriagearrB__content : tcarriagearrB }
 
 function tcarriagearrB__ref_tcarriagearrB__content__projection 
   (a : tcarriagearrB__ref) : tcarriagearrB =
  a.tcarriagearrB__content
 
 meta "model_projection" function tcarriagearrB__ref_tcarriagearrB__content__projection
 
 meta "inline:no" function tcarriagearrB__ref_tcarriagearrB__content__projection
 
 val tcarriagearrB__havoc 
   (x : tcarriagearrB__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "carriagearr" defined at cw.ads:22, created in Gnat2Why.Types.Translate_Type *)
module Cw__carriagearr
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriageslot as Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 type component_type =
  Cw__carriageslot.carriageslot
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (10 : int) }
 
 clone export "ada__model".Constr_Array with axiom .,
 type map = Array__Int__Cw__carriageslot.map, 
 function array_bool_eq = Array__Int__Cw__carriageslot.bool_eq, 
 function first = first, 
 function last = last, 
 type index_rep_type = int

end

(* Module for axiomatizing the array theory associated to type "TreactorarrB" defined at cw.ads:23, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Cw__rod
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep

 function index_I1_one 
   : int =
  (1 : int)
 
 type component_type =
  Cw__rod.rod
 
 clone export "_gnatprove_standard".Array__1 with axiom .,
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool =
  ( (if ((a__first <= a__last)) then (
   ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
   (b__first > b__last))) /\ (forall temp___idx_155   : int.
   (if (( (a__first <= temp___idx_155) /\ (temp___idx_155 <= a__last) )) then (
    ((Cw__rod__rep.to_rep (get a temp___idx_155)) = (Cw__rod__rep.to_rep (get b ((b__first - a__first) + temp___idx_155))))) else true)) )
 val bool_eq 
   (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) : bool
  ensures { result = bool_eq (a : map) (a__first : int) (a__last : int) (b : map) (b__first : int) (b__last : int) }
 
 axiom bool_eq_rev :
  (forall a   b   : map.
  (forall a__first   a__last   b__first   b__last   : int.
   ( ((bool_eq b b__first b__last a a__first a__last) = True) -> ( (if ((a__first <= a__last)) then (
    ( (b__first <= b__last) /\ ((a__last - a__first) = (b__last - b__first)) )) else (
    (b__first > b__last))) /\ (forall temp___idx_155   : int.
    (if (( (a__first <= temp___idx_155) /\ (temp___idx_155 <= a__last) )) then (
     ((Cw__rod__rep.to_rep (get a temp___idx_155)) = (Cw__rod__rep.to_rep (get b ((b__first - a__first) + temp___idx_155))))) else true)) ) )))

end

(* Module for axiomatizing concatenation for the array theory associated to type "TreactorarrB" defined at cw.ads:23, created in Why.Gen.Arrays.Declare_Concatenation_Symbols *)
module Array__Int__Cw__rod__Concat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "_gnatprove_standard".Array__1__Concat with axiom .,
 type component_type = Array__Int__Cw__rod.component_type, 
 type map = Array__Int__Cw__rod.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Cw__rod.get

end

(* Module for axiomatizing comparison for the array theory associated to type "TreactorarrB" defined at cw.ads:23, created in Why.Gen.Arrays.Declare_Comparison_Symbols *)
module Array__Int__Cw__rod_Comp
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rod__rep as Cw__rod__rep
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 function index_Index_one 
   : int =
  (1 : int)
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with axiom .,
 type component_type = Array__Int__Cw__rod.component_type, 
 function to_rep = Cw__rod__rep.to_rep, 
 type map = Array__Int__Cw__rod.map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = Array__Int__Cw__rod.get, 
 function bool_eq = Array__Int__Cw__rod.bool_eq

end

(* Module for axiomatizing type "TreactorarrB" defined at cw.ads:23, created in Gnat2Why.Types.Translate_Type *)
module Cw__TreactorarrB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rod as Cw__rod
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        Cw__TrodrangeB__rep as Cw__TrodrangeB__rep
 use        Cw__rodrange as Cw__rodrange
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 type component_type =
  Cw__rod.rod
 
 function index_1_id 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with axiom .,
 type map = Array__Int__Cw__rod.map, 
 function array_bool_eq = Array__Int__Cw__rod.bool_eq, 
 type index_base_type = Cw__TrodrangeB.trodrangeB, 
 type index_rep_type = int, 
 function to_rep = Cw__TrodrangeB__rep.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Cw__TrodrangeB.in_range, 
 predicate index_dynamic_property = Cw__rodrange.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type treactorarrB =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline:no" function to_array
 
 meta "model_projection" function first
 
 meta "inline:no" function first
 
 meta "model_projection" function last
 
 meta "inline:no" function last
 
 type treactorarrB__ref =
  { mutable treactorarrB__content : treactorarrB }
 
 function treactorarrB__ref_treactorarrB__content__projection 
   (a : treactorarrB__ref) : treactorarrB =
  a.treactorarrB__content
 
 meta "model_projection" function treactorarrB__ref_treactorarrB__content__projection
 
 meta "inline:no" function treactorarrB__ref_treactorarrB__content__projection
 
 val treactorarrB__havoc 
   (x : treactorarrB__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "reactorarr" defined at cw.ads:23, created in Gnat2Why.Types.Translate_Type *)
module Cw__reactorarr
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rod as Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 type component_type =
  Cw__rod.rod
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (4 : int) }
 
 clone export "ada__model".Constr_Array with axiom .,
 type map = Array__Int__Cw__rod.map, 
 function array_bool_eq = Array__Int__Cw__rod.bool_eq, 
 function first = first, 
 function last = last, 
 type index_rep_type = int

end

(* Module for defining the constant "speedmultiplier" defined at cw.ads:25, created in Gnat2Why.Decls.Translate_Constant *)
module Cw__speedmultiplier
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 val constant speedmultiplier [#"cw.ads" 25 0 0][@name:speedMultiplier] [@model_trace:3542] 
   : Float32.t

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module for axiomatizing the record theory associated to type "trainrecord" defined at cw.ads:27, created in Why.Gen.Records.Create_Rep_Record_Theory_If_Needed *)
module Cw__trainrecord__rep
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__energy as Cw__energy
 use        Cw__energy__rep as Cw__energy__rep
 use        Cw__heat as Cw__heat
 use        Cw__heat__rep as Cw__heat__rep
 use        Cw__water as Cw__water
 use        Cw__water__rep as Cw__water__rep
 use        Cw__speed as Cw__speed
 use        Cw__speed__rep as Cw__speed__rep
 use        Cw__increaserrange as Cw__increaserrange
 use        Cw__increaserrange__rep as Cw__increaserrange__rep
 use        Cw__depleterrange as Cw__depleterrange
 use        Cw__depleterrange__rep as Cw__depleterrange__rep

 type __split_fields =
  { rec__cw__trainrecord__temperature [@name:temperature] [@model_trace:.3562] : Cw__heat.heat; rec__cw__trainrecord__tempincreaser [@model_trace:.3572] [@name:tempIncreaser] : Cw__increaserrange.increaserrange; rec__cw__trainrecord__watertank [@name:waterTank] [@model_trace:.3582] : Cw__water.water; rec__cw__trainrecord__waterdepletion [@model_trace:.3592] [@name:waterDepletion] : Cw__depleterrange.depleterrange; rec__cw__trainrecord__currenergy [@model_trace:.3602] [@name:currEnergy] : Cw__energy.energy; rec__cw__trainrecord__currmaxspeed [@model_trace:.3612] [@name:currMaxSpeed] : Cw__speed.speed }
 
 function __split_fields_rec__cw__trainrecord__temperature__projection [@name:temperature] [@model_trace:.3562] 
   (a : __split_fields) : Cw__heat.heat =
  a.rec__cw__trainrecord__temperature
 
 meta "model_projection" function __split_fields_rec__cw__trainrecord__temperature__projection
 
 meta "inline:no" function __split_fields_rec__cw__trainrecord__temperature__projection
 
 function __split_fields_rec__cw__trainrecord__tempincreaser__projection [@model_trace:.3572] [@name:tempIncreaser] 
   (a : __split_fields) : Cw__increaserrange.increaserrange =
  a.rec__cw__trainrecord__tempincreaser
 
 meta "model_projection" function __split_fields_rec__cw__trainrecord__tempincreaser__projection
 
 meta "inline:no" function __split_fields_rec__cw__trainrecord__tempincreaser__projection
 
 function __split_fields_rec__cw__trainrecord__watertank__projection [@name:waterTank] [@model_trace:.3582] 
   (a : __split_fields) : Cw__water.water =
  a.rec__cw__trainrecord__watertank
 
 meta "model_projection" function __split_fields_rec__cw__trainrecord__watertank__projection
 
 meta "inline:no" function __split_fields_rec__cw__trainrecord__watertank__projection
 
 function __split_fields_rec__cw__trainrecord__waterdepletion__projection [@model_trace:.3592] [@name:waterDepletion] 
   (a : __split_fields) : Cw__depleterrange.depleterrange =
  a.rec__cw__trainrecord__waterdepletion
 
 meta "model_projection" function __split_fields_rec__cw__trainrecord__waterdepletion__projection
 
 meta "inline:no" function __split_fields_rec__cw__trainrecord__waterdepletion__projection
 
 function __split_fields_rec__cw__trainrecord__currenergy__projection [@model_trace:.3602] [@name:currEnergy] 
   (a : __split_fields) : Cw__energy.energy =
  a.rec__cw__trainrecord__currenergy
 
 meta "model_projection" function __split_fields_rec__cw__trainrecord__currenergy__projection
 
 meta "inline:no" function __split_fields_rec__cw__trainrecord__currenergy__projection
 
 function __split_fields_rec__cw__trainrecord__currmaxspeed__projection [@model_trace:.3612] [@name:currMaxSpeed] 
   (a : __split_fields) : Cw__speed.speed =
  a.rec__cw__trainrecord__currmaxspeed
 
 meta "model_projection" function __split_fields_rec__cw__trainrecord__currmaxspeed__projection
 
 meta "inline:no" function __split_fields_rec__cw__trainrecord__currmaxspeed__projection
 
 type __split_fields__ref =
  { mutable __split_fields__content : __split_fields }
 
 function __split_fields__ref___split_fields__content__projection 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref___split_fields__content__projection
 
 meta "inline:no" function __split_fields__ref___split_fields__content__projection
 
 val __split_fields__havoc 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type __rep =
  { __split_fields : __split_fields }
 
 function __rep___split_fields__projection 
   (a : __rep) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function __rep___split_fields__projection
 
 meta "inline:no" function __rep___split_fields__projection
 
 function to_base 
   (a : __rep) : __rep =
  a
 val to_base 
   (a : __rep) : __rep
  ensures { result = to_base (a : __rep) }
 
 function of_base 
   (a : __rep) : __rep =
  a
 val of_base 
   (a : __rep) : __rep
  ensures { result = of_base (a : __rep) }
 
 predicate cw__trainrecord__temperature__pred 
   (a : __rep) =
  true
 val cw__trainrecord__temperature__pred 
   (a : __rep) : bool
  ensures { result <-> cw__trainrecord__temperature__pred (a : __rep) }
 
 val rec__cw__trainrecord__temperature_ 
   (a : __rep) : Cw__heat.heat
  requires {  (cw__trainrecord__temperature__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__trainrecord__temperature) }
 
 predicate cw__trainrecord__tempincreaser__pred 
   (a : __rep) =
  true
 val cw__trainrecord__tempincreaser__pred 
   (a : __rep) : bool
  ensures { result <-> cw__trainrecord__tempincreaser__pred (a : __rep) }
 
 val rec__cw__trainrecord__tempincreaser_ 
   (a : __rep) : Cw__increaserrange.increaserrange
  requires {  (cw__trainrecord__tempincreaser__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__trainrecord__tempincreaser) }
 
 predicate cw__trainrecord__watertank__pred 
   (a : __rep) =
  true
 val cw__trainrecord__watertank__pred 
   (a : __rep) : bool
  ensures { result <-> cw__trainrecord__watertank__pred (a : __rep) }
 
 val rec__cw__trainrecord__watertank_ 
   (a : __rep) : Cw__water.water
  requires {  (cw__trainrecord__watertank__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__trainrecord__watertank) }
 
 predicate cw__trainrecord__waterdepletion__pred 
   (a : __rep) =
  true
 val cw__trainrecord__waterdepletion__pred 
   (a : __rep) : bool
  ensures { result <-> cw__trainrecord__waterdepletion__pred (a : __rep) }
 
 val rec__cw__trainrecord__waterdepletion_ 
   (a : __rep) : Cw__depleterrange.depleterrange
  requires {  (cw__trainrecord__waterdepletion__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__trainrecord__waterdepletion) }
 
 predicate cw__trainrecord__currenergy__pred 
   (a : __rep) =
  true
 val cw__trainrecord__currenergy__pred 
   (a : __rep) : bool
  ensures { result <-> cw__trainrecord__currenergy__pred (a : __rep) }
 
 val rec__cw__trainrecord__currenergy_ 
   (a : __rep) : Cw__energy.energy
  requires {  (cw__trainrecord__currenergy__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__trainrecord__currenergy) }
 
 predicate cw__trainrecord__currmaxspeed__pred 
   (a : __rep) =
  true
 val cw__trainrecord__currmaxspeed__pred 
   (a : __rep) : bool
  ensures { result <-> cw__trainrecord__currmaxspeed__pred (a : __rep) }
 
 val rec__cw__trainrecord__currmaxspeed_ 
   (a : __rep) : Cw__speed.speed
  requires {  (cw__trainrecord__currmaxspeed__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__trainrecord__currmaxspeed) }
 
 function bool_eq 
   (a : __rep) (b : __rep) : bool =
  (if (( ( (Float32.eq (Cw__heat__rep.to_rep a.__split_fields.rec__cw__trainrecord__temperature) (Cw__heat__rep.to_rep b.__split_fields.rec__cw__trainrecord__temperature)) /\ ((Cw__increaserrange__rep.to_rep a.__split_fields.rec__cw__trainrecord__tempincreaser) = (Cw__increaserrange__rep.to_rep b.__split_fields.rec__cw__trainrecord__tempincreaser)) )/\( ( (Float32.eq (Cw__water__rep.to_rep a.__split_fields.rec__cw__trainrecord__watertank) (Cw__water__rep.to_rep b.__split_fields.rec__cw__trainrecord__watertank))/\((Cw__depleterrange__rep.to_rep a.__split_fields.rec__cw__trainrecord__waterdepletion) = (Cw__depleterrange__rep.to_rep b.__split_fields.rec__cw__trainrecord__waterdepletion)) )/\( (Float32.eq (Cw__energy__rep.to_rep a.__split_fields.rec__cw__trainrecord__currenergy) (Cw__energy__rep.to_rep b.__split_fields.rec__cw__trainrecord__currenergy))/\(Float32.eq (Cw__speed__rep.to_rep a.__split_fields.rec__cw__trainrecord__currmaxspeed) (Cw__speed__rep.to_rep b.__split_fields.rec__cw__trainrecord__currmaxspeed)) ) ) )) then (
   True) else (
   False))
 val bool_eq 
   (a : __rep) (b : __rep) : bool
  ensures { result = bool_eq (a : __rep) (b : __rep) }

end

(* Module for axiomatizing type "trainrecord" defined at cw.ads:27, created in Gnat2Why.Types.Translate_Type *)
module Cw__trainrecord
 use export Cw__trainrecord__rep
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type trainrecord =
  __rep
 
 val constant value__size 
   : int

 
 val constant object__size 
   : int

 
 val constant alignment 
   : int

 
 axiom value__size_axiom :
  ((value__size ) >= (0 : int))
 
 axiom object__size_axiom :
  ((object__size ) >= (0 : int))
 
 axiom alignment_axiom :
  ((alignment ) >= (0 : int))
 
 val constant cw__trainrecord__temperature__first__bit 
   : int

 
 val constant cw__trainrecord__temperature__last__bit 
   : int

 
 val constant cw__trainrecord__temperature__position 
   : int

 
 axiom cw__trainrecord__temperature__first__bit_axiom :
  ((cw__trainrecord__temperature__first__bit ) >= (0 : int))
 
 axiom cw__trainrecord__temperature__last__bit_axiom :
  ((cw__trainrecord__temperature__last__bit ) > (cw__trainrecord__temperature__first__bit ))
 
 axiom cw__trainrecord__temperature__position_axiom :
  ((cw__trainrecord__temperature__position ) >= (0 : int))
 
 val constant cw__trainrecord__tempincreaser__first__bit 
   : int

 
 val constant cw__trainrecord__tempincreaser__last__bit 
   : int

 
 val constant cw__trainrecord__tempincreaser__position 
   : int

 
 axiom cw__trainrecord__tempincreaser__first__bit_axiom :
  ((cw__trainrecord__tempincreaser__first__bit ) >= (0 : int))
 
 axiom cw__trainrecord__tempincreaser__last__bit_axiom :
  ((cw__trainrecord__tempincreaser__last__bit ) > (cw__trainrecord__tempincreaser__first__bit ))
 
 axiom cw__trainrecord__tempincreaser__position_axiom :
  ((cw__trainrecord__tempincreaser__position ) >= (0 : int))
 
 val constant cw__trainrecord__watertank__first__bit 
   : int

 
 val constant cw__trainrecord__watertank__last__bit 
   : int

 
 val constant cw__trainrecord__watertank__position 
   : int

 
 axiom cw__trainrecord__watertank__first__bit_axiom :
  ((cw__trainrecord__watertank__first__bit ) >= (0 : int))
 
 axiom cw__trainrecord__watertank__last__bit_axiom :
  ((cw__trainrecord__watertank__last__bit ) > (cw__trainrecord__watertank__first__bit ))
 
 axiom cw__trainrecord__watertank__position_axiom :
  ((cw__trainrecord__watertank__position ) >= (0 : int))
 
 val constant cw__trainrecord__waterdepletion__first__bit 
   : int

 
 val constant cw__trainrecord__waterdepletion__last__bit 
   : int

 
 val constant cw__trainrecord__waterdepletion__position 
   : int

 
 axiom cw__trainrecord__waterdepletion__first__bit_axiom :
  ((cw__trainrecord__waterdepletion__first__bit ) >= (0 : int))
 
 axiom cw__trainrecord__waterdepletion__last__bit_axiom :
  ((cw__trainrecord__waterdepletion__last__bit ) > (cw__trainrecord__waterdepletion__first__bit ))
 
 axiom cw__trainrecord__waterdepletion__position_axiom :
  ((cw__trainrecord__waterdepletion__position ) >= (0 : int))
 
 val constant cw__trainrecord__currenergy__first__bit 
   : int

 
 val constant cw__trainrecord__currenergy__last__bit 
   : int

 
 val constant cw__trainrecord__currenergy__position 
   : int

 
 axiom cw__trainrecord__currenergy__first__bit_axiom :
  ((cw__trainrecord__currenergy__first__bit ) >= (0 : int))
 
 axiom cw__trainrecord__currenergy__last__bit_axiom :
  ((cw__trainrecord__currenergy__last__bit ) > (cw__trainrecord__currenergy__first__bit ))
 
 axiom cw__trainrecord__currenergy__position_axiom :
  ((cw__trainrecord__currenergy__position ) >= (0 : int))
 
 val constant cw__trainrecord__currmaxspeed__first__bit 
   : int

 
 val constant cw__trainrecord__currmaxspeed__last__bit 
   : int

 
 val constant cw__trainrecord__currmaxspeed__position 
   : int

 
 axiom cw__trainrecord__currmaxspeed__first__bit_axiom :
  ((cw__trainrecord__currmaxspeed__first__bit ) >= (0 : int))
 
 axiom cw__trainrecord__currmaxspeed__last__bit_axiom :
  ((cw__trainrecord__currmaxspeed__last__bit ) > (cw__trainrecord__currmaxspeed__first__bit ))
 
 axiom cw__trainrecord__currmaxspeed__position_axiom :
  ((cw__trainrecord__currmaxspeed__position ) >= (0 : int))
 
 val function user_eq 
   (a : trainrecord) (b : trainrecord) : bool
 
 val constant dummy 
   : trainrecord

 
 type trainrecord__ref =
  { mutable trainrecord__content : trainrecord }
 
 function trainrecord__ref_trainrecord__content__projection 
   (a : trainrecord__ref) : trainrecord =
  a.trainrecord__content
 
 meta "model_projection" function trainrecord__ref_trainrecord__content__projection
 
 meta "inline:no" function trainrecord__ref_trainrecord__content__projection
 
 val trainrecord__havoc 
   (x : trainrecord__ref) : unit
  writes {x}

end

(* Module for axiomatizing the record theory associated to type "traincarriage" defined at cw.ads:40, created in Why.Gen.Records.Create_Rep_Record_Theory_If_Needed *)
module Cw__traincarriage__rep
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Cw__carriagearr as Cw__carriagearr
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 type __split_fields =
  { rec__cw__traincarriage__carriages [@name:carriages] [@model_trace:.3634] : Array__Int__Cw__carriageslot.map; rec__cw__traincarriage__top [@model_trace:.3644] [@name:Top] : Cw__carriagerange.carriagerange }
 
 function __split_fields_rec__cw__traincarriage__carriages__projection [@name:carriages] [@model_trace:.3634] 
   (a : __split_fields) : Array__Int__Cw__carriageslot.map =
  a.rec__cw__traincarriage__carriages
 
 meta "model_projection" function __split_fields_rec__cw__traincarriage__carriages__projection
 
 meta "inline:no" function __split_fields_rec__cw__traincarriage__carriages__projection
 
 function __split_fields_rec__cw__traincarriage__top__projection [@model_trace:.3644] [@name:Top] 
   (a : __split_fields) : Cw__carriagerange.carriagerange =
  a.rec__cw__traincarriage__top
 
 meta "model_projection" function __split_fields_rec__cw__traincarriage__top__projection
 
 meta "inline:no" function __split_fields_rec__cw__traincarriage__top__projection
 
 type __split_fields__ref =
  { mutable __split_fields__content : __split_fields }
 
 function __split_fields__ref___split_fields__content__2__projection 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref___split_fields__content__2__projection
 
 meta "inline:no" function __split_fields__ref___split_fields__content__2__projection
 
 val __split_fields__havoc 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type __rep =
  { __split_fields : __split_fields }
 
 function __rep___split_fields__2__projection 
   (a : __rep) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function __rep___split_fields__2__projection
 
 meta "inline:no" function __rep___split_fields__2__projection
 
 function to_base 
   (a : __rep) : __rep =
  a
 val to_base 
   (a : __rep) : __rep
  ensures { result = to_base (a : __rep) }
 
 function of_base 
   (a : __rep) : __rep =
  a
 val of_base 
   (a : __rep) : __rep
  ensures { result = of_base (a : __rep) }
 
 predicate cw__traincarriage__carriages__pred 
   (a : __rep) =
  true
 val cw__traincarriage__carriages__pred 
   (a : __rep) : bool
  ensures { result <-> cw__traincarriage__carriages__pred (a : __rep) }
 
 val rec__cw__traincarriage__carriages_ 
   (a : __rep) : Array__Int__Cw__carriageslot.map
  requires {  (cw__traincarriage__carriages__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__traincarriage__carriages) }
 
 predicate cw__traincarriage__top__pred 
   (a : __rep) =
  true
 val cw__traincarriage__top__pred 
   (a : __rep) : bool
  ensures { result <-> cw__traincarriage__top__pred (a : __rep) }
 
 val rec__cw__traincarriage__top_ 
   (a : __rep) : Cw__carriagerange.carriagerange
  requires {  (cw__traincarriage__top__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__traincarriage__top) }
 
 function bool_eq 
   (a : __rep) (b : __rep) : bool =
  (if (( (Cw__carriagearr.bool_eq a.__split_fields.rec__cw__traincarriage__carriages b.__split_fields.rec__cw__traincarriage__carriages) /\ ((Cw__carriagerange__rep.to_rep a.__split_fields.rec__cw__traincarriage__top) = (Cw__carriagerange__rep.to_rep b.__split_fields.rec__cw__traincarriage__top)) )) then (
   True) else (
   False))
 val bool_eq 
   (a : __rep) (b : __rep) : bool
  ensures { result = bool_eq (a : __rep) (b : __rep) }

end

(* Module for axiomatizing type "traincarriage" defined at cw.ads:40, created in Gnat2Why.Types.Translate_Type *)
module Cw__traincarriage
 use export Cw__traincarriage__rep
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type traincarriage =
  __rep
 
 val constant value__size 
   : int

 
 val constant object__size 
   : int

 
 val constant alignment 
   : int

 
 axiom value__size_axiom :
  ((value__size ) >= (0 : int))
 
 axiom object__size_axiom :
  ((object__size ) >= (0 : int))
 
 axiom alignment_axiom :
  ((alignment ) >= (0 : int))
 
 val constant cw__traincarriage__carriages__first__bit 
   : int

 
 val constant cw__traincarriage__carriages__last__bit 
   : int

 
 val constant cw__traincarriage__carriages__position 
   : int

 
 axiom cw__traincarriage__carriages__first__bit_axiom :
  ((cw__traincarriage__carriages__first__bit ) >= (0 : int))
 
 axiom cw__traincarriage__carriages__last__bit_axiom :
  ((cw__traincarriage__carriages__last__bit ) > (cw__traincarriage__carriages__first__bit ))
 
 axiom cw__traincarriage__carriages__position_axiom :
  ((cw__traincarriage__carriages__position ) >= (0 : int))
 
 val constant cw__traincarriage__top__first__bit 
   : int

 
 val constant cw__traincarriage__top__last__bit 
   : int

 
 val constant cw__traincarriage__top__position 
   : int

 
 axiom cw__traincarriage__top__first__bit_axiom :
  ((cw__traincarriage__top__first__bit ) >= (0 : int))
 
 axiom cw__traincarriage__top__last__bit_axiom :
  ((cw__traincarriage__top__last__bit ) > (cw__traincarriage__top__first__bit ))
 
 axiom cw__traincarriage__top__position_axiom :
  ((cw__traincarriage__top__position ) >= (0 : int))
 
 val function user_eq 
   (a : traincarriage) (b : traincarriage) : bool
 
 val constant dummy 
   : traincarriage

 
 type traincarriage__ref =
  { mutable traincarriage__content : traincarriage }
 
 function traincarriage__ref_traincarriage__content__projection 
   (a : traincarriage__ref) : traincarriage =
  a.traincarriage__content
 
 meta "model_projection" function traincarriage__ref_traincarriage__content__projection
 
 meta "inline:no" function traincarriage__ref_traincarriage__content__projection
 
 val traincarriage__havoc 
   (x : traincarriage__ref) : unit
  writes {x}

end

(* Module for axiomatizing the record theory associated to type "train" defined at cw.ads:45, created in Why.Gen.Records.Create_Rep_Record_Theory_If_Needed *)
module Cw__train__rep
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__reactorarr as Cw__reactorarr
 use        Cw__trainrecord as Cw__trainrecord
 use        Cw__traincarriage as Cw__traincarriage
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 type __split_fields =
  { rec__cw__train__stats [@name:stats] [@model_trace:.3669] : Cw__trainrecord.trainrecord; rec__cw__train__ismoving [@name:isMoving] [@model_trace:.3679] : Cw__moving.moving; rec__cw__train__carriage [@model_trace:.3689] [@name:carriage] : Cw__traincarriage.traincarriage; rec__cw__train__reactor [@model_trace:.3699] [@name:reactor] : Array__Int__Cw__rod.map }
 
 function __split_fields_rec__cw__train__stats__projection [@name:stats] [@model_trace:.3669] 
   (a : __split_fields) : Cw__trainrecord.trainrecord =
  a.rec__cw__train__stats
 
 meta "model_projection" function __split_fields_rec__cw__train__stats__projection
 
 meta "inline:no" function __split_fields_rec__cw__train__stats__projection
 
 function __split_fields_rec__cw__train__ismoving__projection [@name:isMoving] [@model_trace:.3679] 
   (a : __split_fields) : Cw__moving.moving =
  a.rec__cw__train__ismoving
 
 meta "model_projection" function __split_fields_rec__cw__train__ismoving__projection
 
 meta "inline:no" function __split_fields_rec__cw__train__ismoving__projection
 
 function __split_fields_rec__cw__train__carriage__projection [@model_trace:.3689] [@name:carriage] 
   (a : __split_fields) : Cw__traincarriage.traincarriage =
  a.rec__cw__train__carriage
 
 meta "model_projection" function __split_fields_rec__cw__train__carriage__projection
 
 meta "inline:no" function __split_fields_rec__cw__train__carriage__projection
 
 function __split_fields_rec__cw__train__reactor__projection [@model_trace:.3699] [@name:reactor] 
   (a : __split_fields) : Array__Int__Cw__rod.map =
  a.rec__cw__train__reactor
 
 meta "model_projection" function __split_fields_rec__cw__train__reactor__projection
 
 meta "inline:no" function __split_fields_rec__cw__train__reactor__projection
 
 type __split_fields__ref =
  { mutable __split_fields__content : __split_fields }
 
 function __split_fields__ref___split_fields__content__3__projection 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref___split_fields__content__3__projection
 
 meta "inline:no" function __split_fields__ref___split_fields__content__3__projection
 
 val __split_fields__havoc 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type __rep =
  { __split_fields : __split_fields }
 
 function __rep___split_fields__3__projection 
   (a : __rep) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function __rep___split_fields__3__projection
 
 meta "inline:no" function __rep___split_fields__3__projection
 
 function to_base 
   (a : __rep) : __rep =
  a
 val to_base 
   (a : __rep) : __rep
  ensures { result = to_base (a : __rep) }
 
 function of_base 
   (a : __rep) : __rep =
  a
 val of_base 
   (a : __rep) : __rep
  ensures { result = of_base (a : __rep) }
 
 predicate cw__train__stats__pred 
   (a : __rep) =
  true
 val cw__train__stats__pred 
   (a : __rep) : bool
  ensures { result <-> cw__train__stats__pred (a : __rep) }
 
 val rec__cw__train__stats_ 
   (a : __rep) : Cw__trainrecord.trainrecord
  requires {  (cw__train__stats__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__train__stats) }
 
 predicate cw__train__ismoving__pred 
   (a : __rep) =
  true
 val cw__train__ismoving__pred 
   (a : __rep) : bool
  ensures { result <-> cw__train__ismoving__pred (a : __rep) }
 
 val rec__cw__train__ismoving_ 
   (a : __rep) : Cw__moving.moving
  requires {  (cw__train__ismoving__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__train__ismoving) }
 
 predicate cw__train__carriage__pred 
   (a : __rep) =
  true
 val cw__train__carriage__pred 
   (a : __rep) : bool
  ensures { result <-> cw__train__carriage__pred (a : __rep) }
 
 val rec__cw__train__carriage_ 
   (a : __rep) : Cw__traincarriage.traincarriage
  requires {  (cw__train__carriage__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__train__carriage) }
 
 predicate cw__train__reactor__pred 
   (a : __rep) =
  true
 val cw__train__reactor__pred 
   (a : __rep) : bool
  ensures { result <-> cw__train__reactor__pred (a : __rep) }
 
 val rec__cw__train__reactor_ 
   (a : __rep) : Array__Int__Cw__rod.map
  requires {  (cw__train__reactor__pred a) }
  ensures {  (result = a.__split_fields.rec__cw__train__reactor) }
 
 function bool_eq 
   (a : __rep) (b : __rep) : bool =
  (if (( ( (Cw__trainrecord.bool_eq a.__split_fields.rec__cw__train__stats b.__split_fields.rec__cw__train__stats) /\ ((Cw__moving__rep.to_rep a.__split_fields.rec__cw__train__ismoving) = (Cw__moving__rep.to_rep b.__split_fields.rec__cw__train__ismoving)) )/\( (Cw__traincarriage.bool_eq a.__split_fields.rec__cw__train__carriage b.__split_fields.rec__cw__train__carriage)/\(Cw__reactorarr.bool_eq a.__split_fields.rec__cw__train__reactor b.__split_fields.rec__cw__train__reactor) ) )) then (
   True) else (
   False))
 val bool_eq 
   (a : __rep) (b : __rep) : bool
  ensures { result = bool_eq (a : __rep) (b : __rep) }

end

(* Module for axiomatizing type "train" defined at cw.ads:45, created in Gnat2Why.Types.Translate_Type *)
module Cw__train
 use export Cw__train__rep
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type train =
  __rep
 
 val constant value__size 
   : int

 
 val constant object__size 
   : int

 
 val constant alignment 
   : int

 
 axiom value__size_axiom :
  ((value__size ) >= (0 : int))
 
 axiom object__size_axiom :
  ((object__size ) >= (0 : int))
 
 axiom alignment_axiom :
  ((alignment ) >= (0 : int))
 
 val constant cw__train__stats__first__bit 
   : int

 
 val constant cw__train__stats__last__bit 
   : int

 
 val constant cw__train__stats__position 
   : int

 
 axiom cw__train__stats__first__bit_axiom :
  ((cw__train__stats__first__bit ) >= (0 : int))
 
 axiom cw__train__stats__last__bit_axiom :
  ((cw__train__stats__last__bit ) > (cw__train__stats__first__bit ))
 
 axiom cw__train__stats__position_axiom :
  ((cw__train__stats__position ) >= (0 : int))
 
 val constant cw__train__ismoving__first__bit 
   : int

 
 val constant cw__train__ismoving__last__bit 
   : int

 
 val constant cw__train__ismoving__position 
   : int

 
 axiom cw__train__ismoving__first__bit_axiom :
  ((cw__train__ismoving__first__bit ) >= (0 : int))
 
 axiom cw__train__ismoving__last__bit_axiom :
  ((cw__train__ismoving__last__bit ) > (cw__train__ismoving__first__bit ))
 
 axiom cw__train__ismoving__position_axiom :
  ((cw__train__ismoving__position ) >= (0 : int))
 
 val constant cw__train__carriage__first__bit 
   : int

 
 val constant cw__train__carriage__last__bit 
   : int

 
 val constant cw__train__carriage__position 
   : int

 
 axiom cw__train__carriage__first__bit_axiom :
  ((cw__train__carriage__first__bit ) >= (0 : int))
 
 axiom cw__train__carriage__last__bit_axiom :
  ((cw__train__carriage__last__bit ) > (cw__train__carriage__first__bit ))
 
 axiom cw__train__carriage__position_axiom :
  ((cw__train__carriage__position ) >= (0 : int))
 
 val constant cw__train__reactor__first__bit 
   : int

 
 val constant cw__train__reactor__last__bit 
   : int

 
 val constant cw__train__reactor__position 
   : int

 
 axiom cw__train__reactor__first__bit_axiom :
  ((cw__train__reactor__first__bit ) >= (0 : int))
 
 axiom cw__train__reactor__last__bit_axiom :
  ((cw__train__reactor__last__bit ) > (cw__train__reactor__first__bit ))
 
 axiom cw__train__reactor__position_axiom :
  ((cw__train__reactor__position ) >= (0 : int))
 
 val function user_eq 
   (a : train) (b : train) : bool
 
 val constant dummy 
   : train

 
 type train__ref =
  { mutable train__content : train }
 
 function train__ref_train__content__projection 
   (a : train__ref) : train =
  a.train__content
 
 meta "model_projection" function train__ref_train__content__projection
 
 meta "inline:no" function train__ref_train__content__projection
 
 val train__havoc 
   (x : train__ref) : unit
  writes {x}

end

(* Module for defining the constant "t" defined at cw.ads:85, created in Gnat2Why.Decls.Translate_Constant *)
module Cw__istrainmoving__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val constant t [#"cw.ads" 85 0 0][@model_projected] [@name:t] [@model_trace:4363] 
   : Cw__train.train

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:85, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__istrainmoving__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "istrainmoving" defined at cw.ads:85, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__istrainmoving
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val function istrainmoving 
   (t : Cw__train.train) : bool
 
 val predicate istrainmoving__function_guard 
   (temp___result_156 : bool) (t : Cw__train.train)

end

(* Module for axiomatizing type "T26s" defined at cw.ads:54, created in Gnat2Why.Types.Translate_Type *)
module Cw__emptycarriage__L25s__T26s
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        Cw__TcarriagerangeB__rep as Cw__TcarriagerangeB__rep

 type t26s =
  Cw__TcarriagerangeB.tcarriagerangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t26s, 
 type rep_type = int, 
 function base_to_rep = Cw__TcarriagerangeB__rep.to_rep, 
 function base_of_rep = Cw__TcarriagerangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t26s__ref =
  { mutable t26s__content : t26s }
 
 function t26s__ref_t26s__content__projection 
   (a : t26s__ref) : t26s =
  a.t26s__content
 
 meta "model_projection" function t26s__ref_t26s__content__projection
 
 meta "inline:no" function t26s__ref_t26s__content__projection
 
 val t26s__havoc 
   (x : t26s__ref) : unit
  writes {x}

end

(* Module for defining the constant "n" defined at cw.ads:61, created in Gnat2Why.Decls.Translate_Constant *)
module Cw__loadrod__n
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant n [#"cw.ads" 61 0 0][@name:n] [@model_trace:3950] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "n" defined at cw.ads:61, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadrod__n___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the constant "t" defined at cw.ads:83, created in Gnat2Why.Decls.Translate_Constant *)
module Cw__loadedrods__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val constant t [#"cw.ads" 83 0 0][@model_projected] [@name:t] [@model_trace:4344] 
   : Cw__train.train

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:83, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadedrods__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "loadedrods" defined at cw.ads:83, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__loadedrods
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val function loadedrods 
   (t : Cw__train.train) : int
 
 val predicate loadedrods__function_guard 
   (temp___result_157 : int) (t : Cw__train.train)

end

(* Module for defining the constant "n" defined at cw.ads:64, created in Gnat2Why.Decls.Translate_Constant *)
module Cw__unloadrod__n
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant n [#"cw.ads" 64 0 0][@name:n] [@model_trace:4026] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "n" defined at cw.ads:64, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__unloadrod__n___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for axiomatizing type "T28s" defined at cw.ads:69, created in Gnat2Why.Types.Translate_Type *)
module Cw__maintenancemodeon__L27s__T28s
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        Cw__TrodrangeB__rep as Cw__TrodrangeB__rep

 type t28s =
  Cw__TrodrangeB.trodrangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t28s, 
 type rep_type = int, 
 function base_to_rep = Cw__TrodrangeB__rep.to_rep, 
 function base_of_rep = Cw__TrodrangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t28s__ref =
  { mutable t28s__content : t28s }
 
 function t28s__ref_t28s__content__projection 
   (a : t28s__ref) : t28s =
  a.t28s__content
 
 meta "model_projection" function t28s__ref_t28s__content__projection
 
 meta "inline:no" function t28s__ref_t28s__content__projection
 
 val t28s__havoc 
   (x : t28s__ref) : unit
  writes {x}

end

(* Module for defining the constant "t" defined at cw.ads:82, created in Gnat2Why.Decls.Translate_Constant *)
module Cw__connectedcarriages__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val constant t [#"cw.ads" 82 0 0][@model_trace:4325] [@model_projected] [@name:t] 
   : Cw__train.train

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:82, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__connectedcarriages__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "connectedcarriages" defined at cw.ads:82, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__connectedcarriages
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val function connectedcarriages 
   (t : Cw__train.train) : int
 
 val predicate connectedcarriages__function_guard 
   (temp___result_158 : int) (t : Cw__train.train)

end

(* Module for axiomatizing type "TcountB" defined at a-textio.ads:77, created in Gnat2Why.Types.Translate_Type *)
module Ada__text_io__TcountB
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type tcountB =
  < range -2147483648 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (( -2147483648) : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = tcountB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type tcountB__ref =
  { mutable tcountB__content : tcountB }
 
 function tcountB__ref_tcountB__content__projection 
   (a : tcountB__ref) : tcountB =
  a.tcountB__content
 
 meta "model_projection" function tcountB__ref_tcountB__content__projection
 
 meta "inline:no" function tcountB__ref_tcountB__content__projection
 
 val tcountB__havoc 
   (x : tcountB__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "TcountB" defined at a-textio.ads:77, created in Gnat2Why.Types.Translate_Type *)
module Ada__text_io__TcountB__rep
 use        Ada__text_io__TcountB as Ada__text_io__TcountB
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Ada__text_io__TcountB.tcountB) : int =
  (Ada__text_io__TcountB.tcountB'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Ada__text_io__TcountB.tcountB, 
 predicate in_range = Ada__text_io__TcountB.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "count" defined at a-textio.ads:77, created in Gnat2Why.Types.Translate_Type *)
module Ada__text_io__count
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type count =
  < range 0 2147483647 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (2147483647 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = count, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type count__ref =
  { mutable count__content : count }
 
 function count__ref_count__content__projection 
   (a : count__ref) : count =
  a.count__content
 
 meta "model_projection" function count__ref_count__content__projection
 
 meta "inline:no" function count__ref_count__content__projection
 
 val count__havoc 
   (x : count__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "count" defined at a-textio.ads:77, created in Gnat2Why.Types.Translate_Type *)
module Ada__text_io__count__rep
 use        Ada__text_io__count as Ada__text_io__count
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Ada__text_io__count.count) : int =
  (Ada__text_io__count.count'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Ada__text_io__count.count, 
 predicate in_range = Ada__text_io__count.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "T1b" defined at cw.adb:7, created in Gnat2Why.Types.Translate_Type *)
module Cw__emptycarriage__L_1__T1b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        Cw__TcarriagerangeB__rep as Cw__TcarriagerangeB__rep

 type t1b =
  Cw__TcarriagerangeB.tcarriagerangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t1b, 
 type rep_type = int, 
 function base_to_rep = Cw__TcarriagerangeB__rep.to_rep, 
 function base_of_rep = Cw__TcarriagerangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t1b__ref =
  { mutable t1b__content : t1b }
 
 function t1b__ref_t1b__content__projection 
   (a : t1b__ref) : t1b =
  a.t1b__content
 
 meta "model_projection" function t1b__ref_t1b__content__projection
 
 meta "inline:no" function t1b__ref_t1b__content__projection
 
 val t1b__havoc 
   (x : t1b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T5b" defined at cw.adb:9, created in Gnat2Why.Types.Translate_Type *)
module Cw__emptycarriage__L_1__L4b__T5b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        Cw__TcarriagerangeB__rep as Cw__TcarriagerangeB__rep

 type t5b =
  Cw__TcarriagerangeB.tcarriagerangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t5b, 
 type rep_type = int, 
 function base_to_rep = Cw__TcarriagerangeB__rep.to_rep, 
 function base_of_rep = Cw__TcarriagerangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t5b__ref =
  { mutable t5b__content : t5b }
 
 function t5b__ref_t5b__content__projection 
   (a : t5b__ref) : t5b =
  a.t5b__content
 
 meta "model_projection" function t5b__ref_t5b__content__projection
 
 meta "inline:no" function t5b__ref_t5b__content__projection
 
 val t5b__havoc 
   (x : t5b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T3b" defined at cw.adb:9, created in Gnat2Why.Types.Translate_Type *)
module Cw__emptycarriage__L_1__L2b__T3b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        Cw__TcarriagerangeB__rep as Cw__TcarriagerangeB__rep

 type t3b =
  Cw__TcarriagerangeB.tcarriagerangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t3b, 
 type rep_type = int, 
 function base_to_rep = Cw__TcarriagerangeB__rep.to_rep, 
 function base_of_rep = Cw__TcarriagerangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t3b__ref =
  { mutable t3b__content : t3b }
 
 function t3b__ref_t3b__content__projection 
   (a : t3b__ref) : t3b =
  a.t3b__content
 
 meta "model_projection" function t3b__ref_t3b__content__projection
 
 meta "inline:no" function t3b__ref_t3b__content__projection
 
 val t3b__havoc 
   (x : t3b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T6b" defined at cw.adb:48, created in Gnat2Why.Types.Translate_Type *)
module Cw__maintenancemodeon__L_2__T6b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        Cw__TrodrangeB__rep as Cw__TrodrangeB__rep

 type t6b =
  Cw__TrodrangeB.trodrangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t6b, 
 type rep_type = int, 
 function base_to_rep = Cw__TrodrangeB__rep.to_rep, 
 function base_of_rep = Cw__TrodrangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t6b__ref =
  { mutable t6b__content : t6b }
 
 function t6b__ref_t6b__content__projection 
   (a : t6b__ref) : t6b =
  a.t6b__content
 
 meta "model_projection" function t6b__ref_t6b__content__projection
 
 meta "inline:no" function t6b__ref_t6b__content__projection
 
 val t6b__havoc 
   (x : t6b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T10b" defined at cw.adb:50, created in Gnat2Why.Types.Translate_Type *)
module Cw__maintenancemodeon__L_2__L9b__T10b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        Cw__TrodrangeB__rep as Cw__TrodrangeB__rep

 type t10b =
  Cw__TrodrangeB.trodrangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t10b, 
 type rep_type = int, 
 function base_to_rep = Cw__TrodrangeB__rep.to_rep, 
 function base_of_rep = Cw__TrodrangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t10b__ref =
  { mutable t10b__content : t10b }
 
 function t10b__ref_t10b__content__projection 
   (a : t10b__ref) : t10b =
  a.t10b__content
 
 meta "model_projection" function t10b__ref_t10b__content__projection
 
 meta "inline:no" function t10b__ref_t10b__content__projection
 
 val t10b__havoc 
   (x : t10b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T8b" defined at cw.adb:50, created in Gnat2Why.Types.Translate_Type *)
module Cw__maintenancemodeon__L_2__L7b__T8b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        Cw__TrodrangeB__rep as Cw__TrodrangeB__rep

 type t8b =
  Cw__TrodrangeB.trodrangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t8b, 
 type rep_type = int, 
 function base_to_rep = Cw__TrodrangeB__rep.to_rep, 
 function base_of_rep = Cw__TrodrangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t8b__ref =
  { mutable t8b__content : t8b }
 
 function t8b__ref_t8b__content__projection 
   (a : t8b__ref) : t8b =
  a.t8b__content
 
 meta "model_projection" function t8b__ref_t8b__content__projection
 
 meta "inline:no" function t8b__ref_t8b__content__projection
 
 val t8b__havoc 
   (x : t8b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T11b" defined at cw.adb:69, created in Gnat2Why.Types.Translate_Type *)
module Cw__connectedcarriages__L_3__T11b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TcarriagerangeB as Cw__TcarriagerangeB
 use        Cw__TcarriagerangeB__rep as Cw__TcarriagerangeB__rep

 type t11b =
  Cw__TcarriagerangeB.tcarriagerangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t11b, 
 type rep_type = int, 
 function base_to_rep = Cw__TcarriagerangeB__rep.to_rep, 
 function base_of_rep = Cw__TcarriagerangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t11b__ref =
  { mutable t11b__content : t11b }
 
 function t11b__ref_t11b__content__projection 
   (a : t11b__ref) : t11b =
  a.t11b__content
 
 meta "model_projection" function t11b__ref_t11b__content__projection
 
 meta "inline:no" function t11b__ref_t11b__content__projection
 
 val t11b__havoc 
   (x : t11b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T13b" defined at cw.adb:83, created in Gnat2Why.Types.Translate_Type *)
module Cw__loadedrods__L_4__T13b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__TrodrangeB as Cw__TrodrangeB
 use        Cw__TrodrangeB__rep as Cw__TrodrangeB__rep

 type t13b =
  Cw__TrodrangeB.trodrangeB
 
 predicate dynamic_property 
   (first_int : int) (last_int : int) (x : int) =
  ( (first_int <= x) /\ (x <= last_int) )
 val dynamic_property 
   (first_int : int) (last_int : int) (x : int) : bool
  ensures { result <-> dynamic_property (first_int : int) (last_int : int) (x : int) }
 
 clone export "ada__model".Dynamic_Discrete with axiom .,
 type t = t13b, 
 type rep_type = int, 
 function base_to_rep = Cw__TrodrangeB__rep.to_rep, 
 function base_of_rep = Cw__TrodrangeB__rep.of_rep, 
 predicate dynamic_property = dynamic_property
 
 type t13b__ref =
  { mutable t13b__content : t13b }
 
 function t13b__ref_t13b__content__projection 
   (a : t13b__ref) : t13b =
  a.t13b__content
 
 meta "model_projection" function t13b__ref_t13b__content__projection
 
 meta "inline:no" function t13b__ref_t13b__content__projection
 
 val t13b__havoc 
   (x : t13b__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T15b" defined at cw.adb:137, created in Gnat2Why.Types.Translate_Type *)
module Cw__movetrain__T15b
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character

 type component_type =
  Standard__character.character
 
 val constant first 
   : int
  ensures { result =  (1 : int) }
 
 val constant last 
   : int
  ensures { result =  (25 : int) }
 
 clone export "ada__model".Constr_Array with axiom .,
 type map = Array__Int__Standard__character.map, 
 function array_bool_eq = Array__Int__Standard__character.bool_eq, 
 function first = first, 
 function last = last, 
 type index_rep_type = int

end

(* Module for defining the constant "item" defined at a-textio.ads:465, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__text_io__put__4__item
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Standard__string as Standard__string

 val constant item [#"a-textio.ads" 465 0 0][@name:Item] [@model_projected] [@model_trace:7416] 
   : Standard__string.string

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "item" defined at a-textio.ads:465, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__text_io__put__4__item___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for axiomatizing type "field" defined at a-textio.ads:86, created in Gnat2Why.Types.Translate_Type *)
module Ada__text_io__field
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int

 type field =
  < range 0 255 >
 
 val constant first 
   : int
  ensures { result =  (0 : int) }
 
 val constant last 
   : int
  ensures { result =  (255 : int) }
 
 predicate in_range 
   (x : int) =
  ( (first <= x) /\ (x <= last) )
 val in_range 
   (x : int) : bool
  ensures { result <-> in_range (x : int) }
 
 clone export "ada__model".Static_Discrete with axiom .,
 type t = field, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type field__ref =
  { mutable field__content : field }
 
 function field__ref_field__content__projection 
   (a : field__ref) : field =
  a.field__content
 
 meta "model_projection" function field__ref_field__content__projection
 
 meta "inline:no" function field__ref_field__content__projection
 
 val field__havoc 
   (x : field__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "field" defined at a-textio.ads:86, created in Gnat2Why.Types.Translate_Type *)
module Ada__text_io__field__rep
 use        Ada__text_io__field as Ada__text_io__field
 use        "_gnatprove_standard".Main
 use        "int".Int

 function to_rep 
   (x : Ada__text_io__field.field) : int =
  (Ada__text_io__field.field'int x)
 
 clone export "ada__model".Rep_Proj_Int with axiom .,
 type t = Ada__text_io__field.field, 
 predicate in_range = Ada__text_io__field.in_range, 
 function to_rep = to_rep
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for axiomatizing type "num" defined at a-tiflio.ads:44 instantiated at a-flteio.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Ada__float_text_io__num
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 type num 
 
 val constant first 
   : Float32.t
  ensures { result =  (Float32.neg (340282346638528859811704183484516925440.0:Float32.t)) }
 
 val constant last 
   : Float32.t
  ensures { result =  (340282346638528859811704183484516925440.0:Float32.t) }
 
 predicate in_range 
   (x : Float32.t) =
  (Float32.t'isFinite x)
 val in_range 
   (x : Float32.t) : bool
  ensures { result <-> in_range (x : Float32.t) }
 
 clone export "ada__model".Static_Float32 with axiom .,
 type t = num, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 type num__ref =
  { mutable num__content : num }
 
 function num__ref_num__content__projection 
   (a : num__ref) : num =
  a.num__content
 
 meta "model_projection" function num__ref_num__content__projection
 
 meta "inline:no" function num__ref_num__content__projection
 
 val num__havoc 
   (x : num__ref) : unit
  writes {x}

end

(* Module defining to_rep/of_rep for type "num" defined at a-tiflio.ads:44 instantiated at a-flteio.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Ada__float_text_io__num__rep
 use        Ada__float_text_io__num as Ada__float_text_io__num
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Main
 use        "int".Int

 clone export "ada__model".Rep_Proj_Float32 with axiom .,
 type t = Ada__float_text_io__num.num, 
 predicate in_range = Ada__float_text_io__num.in_range
 
 meta "model_projection" function to_rep
 
 meta "inline:no" function to_rep

end

(* Module for defining the constant "item" defined at a-tiflio.ads:83 instantiated at a-flteio.ads:20, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__float_text_io__put__2__item
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 val constant item [#"a-tiflio.ads" 83 0 0][@name:Item] [@model_trace:20995] 
   : Float32.t

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "item" defined at a-tiflio.ads:83 instantiated at a-flteio.ads:20, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__float_text_io__put__2__item___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the constant "fore" defined at a-tiflio.ads:84 instantiated at a-flteio.ads:20, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__float_text_io__put__2__fore
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant fore [#"a-tiflio.ads" 84 0 0][@model_trace:21004] [@name:Fore] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "fore" defined at a-tiflio.ads:84 instantiated at a-flteio.ads:20, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__float_text_io__put__2__fore___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the constant "aft" defined at a-tiflio.ads:85 instantiated at a-flteio.ads:20, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__float_text_io__put__2__aft
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant aft [#"a-tiflio.ads" 85 0 0][@model_trace:21014] [@name:Aft] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "aft" defined at a-tiflio.ads:85 instantiated at a-flteio.ads:20, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__float_text_io__put__2__aft___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the constant "exp" defined at a-tiflio.ads:86 instantiated at a-flteio.ads:20, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__float_text_io__put__2__exp
 use        "_gnatprove_standard".Main
 use        "int".Int

 val constant exp [#"a-tiflio.ads" 86 0 0][@name:Exp] [@model_trace:21024] 
   : int

 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "exp" defined at a-tiflio.ads:86 instantiated at a-flteio.ads:20, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__float_text_io__put__2__exp___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end
(* Module for defining a ref holding the value of variable "t" defined at cw.ads:52, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__emptycarriage__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 52 0 0][@model_projected] [@name:t] [@model_trace:3718]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:52, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__emptycarriage__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:55, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__unloadcarriage__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 55 0 0][@model_projected] [@name:t] [@model_trace:3799]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:55, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__unloadcarriage__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:58, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__loadcarriage__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 58 0 0][@model_trace:3870] [@model_projected] [@name:t]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:58, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadcarriage__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:61, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__loadrod__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 61 0 0][@model_projected] [@name:t] [@model_trace:3941]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:61, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadrod__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:64, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__unloadrod__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 64 0 0][@model_trace:4017] [@model_projected] [@name:t]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:64, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__unloadrod__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:67, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__maintenancemodeon__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 67 0 0][@model_projected] [@name:t] [@model_trace:4095]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:67, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__maintenancemodeon__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:70, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__maintenancemodeoff__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 70 0 0][@model_projected] [@model_trace:4157] [@name:t]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:70, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__maintenancemodeoff__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:73, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__updatestats__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 73 0 0][@model_trace:4191] [@model_projected] [@name:t]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:73, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__updatestats__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:76, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__refillwater__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 76 0 0][@model_projected] [@name:t] [@model_trace:4254]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:76, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__refillwater__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "t" defined at cw.ads:79, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__movetrain__t
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train

 val t__split_fields [#"cw.ads" 79 0 0][@model_projected] [@name:t] [@model_trace:4292]  : Cw__train.__split_fields__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "t" defined at cw.ads:79, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__movetrain__t___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "pos" defined at cw.adb:7, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__emptycarriage__L_1__pos
 use        "_gnatprove_standard".Main
 use        "int".Int

 val pos [#"cw.adb" 7 0 0][@model_projected] [@model_trace:2344] [@name:Pos]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "pos" defined at cw.adb:7, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__emptycarriage__L_1__pos___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "r" defined at cw.adb:48, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__maintenancemodeon__L_2__r
 use        "_gnatprove_standard".Main
 use        "int".Int

 val r [#"cw.adb" 48 0 0][@model_trace:2645] [@model_projected] [@name:r]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "r" defined at cw.adb:48, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__maintenancemodeon__L_2__r___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "count" defined at cw.adb:66, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__connectedcarriages__count
 use        "_gnatprove_standard".Main
 use        "int".Int

 val count [#"cw.adb" 66 0 0][@model_projected] [@name:count] [@model_trace:2760]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "count" defined at cw.adb:66, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__connectedcarriages__count___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "j" defined at cw.adb:69, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__connectedcarriages__L_3__j
 use        "_gnatprove_standard".Main
 use        "int".Int

 val j [#"cw.adb" 69 0 0][@model_projected] [@model_trace:2774] [@name:J]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "j" defined at cw.adb:69, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__connectedcarriages__L_3__j___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "count" defined at cw.adb:80, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__loadedrods__count
 use        "_gnatprove_standard".Main
 use        "int".Int

 val count [#"cw.adb" 80 0 0][@model_trace:2831] [@model_projected] [@name:count]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "count" defined at cw.adb:80, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadedrods__count___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "j" defined at cw.adb:83, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__loadedrods__L_4__j
 use        "_gnatprove_standard".Main
 use        "int".Int

 val j [#"cw.adb" 83 0 0][@model_projected] [@name:J] [@model_trace:2845]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "j" defined at cw.adb:83, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadedrods__L_4__j___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "carrcount" defined at cw.adb:94, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__updatestats__carrcount
 use        "_gnatprove_standard".Main
 use        "int".Int

 val carrcount [#"cw.adb" 94 0 0][@name:carrCount] [@model_projected] [@model_trace:2900]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "carrcount" defined at cw.adb:94, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__updatestats__carrcount___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "rodcount" defined at cw.adb:95, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__updatestats__rodcount
 use        "_gnatprove_standard".Main
 use        "int".Int

 val rodcount [#"cw.adb" 95 0 0][@model_trace:2912] [@model_projected] [@name:rodCount]  : int__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "rodcount" defined at cw.adb:95, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__updatestats__rodcount___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "distancemade" defined at cw.adb:121, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__movetrain__distancemade
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 val distancemade [#"cw.adb" 121 0 0][@model_projected] [@model_trace:3138] [@name:distanceMade]  : Float32.t__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "distancemade" defined at cw.adb:121, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__movetrain__distancemade___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining a ref holding the value of variable "hoursonheat" defined at cw.adb:122, created in Gnat2Why.Decls.Translate_Variable *)
module Cw__movetrain__hoursonheat
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32

 val hoursonheat [#"cw.adb" 122 0 0][@name:hoursOnHeat] [@model_trace:3147] [@model_projected]  : Float32.t__ref 
 
 val constant attr__ATTRIBUTE_ADDRESS 
   : int


end

(* Module giving an empty axiom for the entity "hoursonheat" defined at cw.adb:122, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__movetrain__hoursonheat___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module declaring the external object "ada__text_io__standard_in," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__standard_in
 use        "_gnatprove_standard".Main
 use        "int".Int

 val standard_in  : Main.__private__ref 

end

(* Module declaring the external object "ada__text_io__file_system," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__file_system
 use        "_gnatprove_standard".Main
 use        "int".Int

 val file_system  : Main.__private__ref 

end

(* Module declaring the external object "ada__text_io__standard_out," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__standard_out
 use        "_gnatprove_standard".Main
 use        "int".Int

 val standard_out  : Main.__private__ref 

end

(* Module declaring the external object "ada__text_io__standard_err," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__standard_err
 use        "_gnatprove_standard".Main
 use        "int".Int

 val standard_err  : Main.__private__ref 

end

(* Module declaring the external object "ada__text_io__current_in," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__current_in
 use        "_gnatprove_standard".Main
 use        "int".Int

 val current_in  : Main.__private__ref 

end

(* Module declaring the external object "ada__text_io__current_out," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__current_out
 use        "_gnatprove_standard".Main
 use        "int".Int

 val current_out  : Main.__private__ref 

end

(* Module declaring the external object "ada__text_io__current_err," created in Gnat2Why.Decls.Translate_External_Object *)
module Ada__text_io__current_err
 use        "_gnatprove_standard".Main
 use        "int".Int

 val current_err  : Main.__private__ref 

end
(* Module giving axioms for type "short_short_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__short_short_integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__short_short_integer as Standard__short_short_integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_4 : int) (temp___is_init_0 : bool) (temp___skip_constant_1 : bool) (temp___do_toplevel_2 : bool) (temp___do_typ_inv_3 : bool) =
  (if (( temp___is_init_0 \/ (Standard__short_short_integer.first <= Standard__short_short_integer.last) )) then (
   (Standard__short_short_integer.dynamic_property Standard__short_short_integer.first Standard__short_short_integer.last temp___expr_4)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_4 : int) (temp___is_init_0 : bool) (temp___skip_constant_1 : bool) (temp___do_toplevel_2 : bool) (temp___do_typ_inv_3 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_4 : int) (temp___is_init_0 : bool) (temp___skip_constant_1 : bool) (temp___do_toplevel_2 : bool) (temp___do_typ_inv_3 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_5 : int) (temp___skip_top_level_6 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_5 : int) (temp___skip_top_level_6 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_5 : int) (temp___skip_top_level_6 : bool) }

end

(* Module giving axioms for type "short_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__short_integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__short_integer as Standard__short_integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_11 : int) (temp___is_init_7 : bool) (temp___skip_constant_8 : bool) (temp___do_toplevel_9 : bool) (temp___do_typ_inv_10 : bool) =
  (if (( temp___is_init_7 \/ (Standard__short_integer.first <= Standard__short_integer.last) )) then (
   (Standard__short_integer.dynamic_property Standard__short_integer.first Standard__short_integer.last temp___expr_11)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_11 : int) (temp___is_init_7 : bool) (temp___skip_constant_8 : bool) (temp___do_toplevel_9 : bool) (temp___do_typ_inv_10 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_11 : int) (temp___is_init_7 : bool) (temp___skip_constant_8 : bool) (temp___do_toplevel_9 : bool) (temp___do_typ_inv_10 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_12 : int) (temp___skip_top_level_13 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_12 : int) (temp___skip_top_level_13 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_12 : int) (temp___skip_top_level_13 : bool) }

end

(* Module giving axioms for type "integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer as Standard__integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) =
  (if (( temp___is_init_14 \/ (Standard__integer.first <= Standard__integer.last) )) then (
   (Standard__integer.dynamic_property Standard__integer.first Standard__integer.last temp___expr_18)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_18 : int) (temp___is_init_14 : bool) (temp___skip_constant_15 : bool) (temp___do_toplevel_16 : bool) (temp___do_typ_inv_17 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_19 : int) (temp___skip_top_level_20 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_19 : int) (temp___skip_top_level_20 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_19 : int) (temp___skip_top_level_20 : bool) }

end

(* Module giving axioms for type "long_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__long_integer as Standard__long_integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_25 : int) (temp___is_init_21 : bool) (temp___skip_constant_22 : bool) (temp___do_toplevel_23 : bool) (temp___do_typ_inv_24 : bool) =
  (if (( temp___is_init_21 \/ (Standard__long_integer.first <= Standard__long_integer.last) )) then (
   (Standard__long_integer.dynamic_property Standard__long_integer.first Standard__long_integer.last temp___expr_25)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_25 : int) (temp___is_init_21 : bool) (temp___skip_constant_22 : bool) (temp___do_toplevel_23 : bool) (temp___do_typ_inv_24 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_25 : int) (temp___is_init_21 : bool) (temp___skip_constant_22 : bool) (temp___do_toplevel_23 : bool) (temp___do_typ_inv_24 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_26 : int) (temp___skip_top_level_27 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_26 : int) (temp___skip_top_level_27 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_26 : int) (temp___skip_top_level_27 : bool) }

end

(* Module giving axioms for type "long_long_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_long_integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__long_long_integer as Standard__long_long_integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_32 : int) (temp___is_init_28 : bool) (temp___skip_constant_29 : bool) (temp___do_toplevel_30 : bool) (temp___do_typ_inv_31 : bool) =
  (if (( temp___is_init_28 \/ (Standard__long_long_integer.first <= Standard__long_long_integer.last) )) then (
   (Standard__long_long_integer.dynamic_property Standard__long_long_integer.first Standard__long_long_integer.last temp___expr_32)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_32 : int) (temp___is_init_28 : bool) (temp___skip_constant_29 : bool) (temp___do_toplevel_30 : bool) (temp___do_typ_inv_31 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_32 : int) (temp___is_init_28 : bool) (temp___skip_constant_29 : bool) (temp___do_toplevel_30 : bool) (temp___do_typ_inv_31 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_33 : int) (temp___skip_top_level_34 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_33 : int) (temp___skip_top_level_34 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_33 : int) (temp___skip_top_level_34 : bool) }

end

(* Module giving axioms for type "natural", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__natural___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__natural as Standard__natural

 predicate dynamic_invariant [@inline] 
   (temp___expr_39 : int) (temp___is_init_35 : bool) (temp___skip_constant_36 : bool) (temp___do_toplevel_37 : bool) (temp___do_typ_inv_38 : bool) =
  (if (( temp___is_init_35 \/ (Standard__natural.first <= Standard__natural.last) )) then (
   (Standard__natural.dynamic_property Standard__natural.first Standard__natural.last temp___expr_39)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_39 : int) (temp___is_init_35 : bool) (temp___skip_constant_36 : bool) (temp___do_toplevel_37 : bool) (temp___do_typ_inv_38 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_39 : int) (temp___is_init_35 : bool) (temp___skip_constant_36 : bool) (temp___do_toplevel_37 : bool) (temp___do_typ_inv_38 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_40 : int) (temp___skip_top_level_41 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_40 : int) (temp___skip_top_level_41 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_40 : int) (temp___skip_top_level_41 : bool) }

end

(* Module giving axioms for type "positive", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__positive___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__positive as Standard__positive

 predicate dynamic_invariant [@inline] 
   (temp___expr_46 : int) (temp___is_init_42 : bool) (temp___skip_constant_43 : bool) (temp___do_toplevel_44 : bool) (temp___do_typ_inv_45 : bool) =
  (if (( temp___is_init_42 \/ (Standard__positive.first <= Standard__positive.last) )) then (
   (Standard__positive.dynamic_property Standard__positive.first Standard__positive.last temp___expr_46)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_46 : int) (temp___is_init_42 : bool) (temp___skip_constant_43 : bool) (temp___do_toplevel_44 : bool) (temp___do_typ_inv_45 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_46 : int) (temp___is_init_42 : bool) (temp___skip_constant_43 : bool) (temp___do_toplevel_44 : bool) (temp___do_typ_inv_45 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_47 : int) (temp___skip_top_level_48 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_47 : int) (temp___skip_top_level_48 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_47 : int) (temp___skip_top_level_48 : bool) }

end

(* Module giving axioms for type "short_float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__short_float___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Standard__short_float as Standard__short_float

 predicate dynamic_invariant [@inline] 
   (temp___expr_53 : Float32.t) (temp___is_init_49 : bool) (temp___skip_constant_50 : bool) (temp___do_toplevel_51 : bool) (temp___do_typ_inv_52 : bool) =
  (if (( temp___is_init_49 \/ (Float32.le Standard__short_float.first Standard__short_float.last) )) then (
   (Standard__short_float.dynamic_property Standard__short_float.first Standard__short_float.last temp___expr_53)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_53 : Float32.t) (temp___is_init_49 : bool) (temp___skip_constant_50 : bool) (temp___do_toplevel_51 : bool) (temp___do_typ_inv_52 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_53 : Float32.t) (temp___is_init_49 : bool) (temp___skip_constant_50 : bool) (temp___do_toplevel_51 : bool) (temp___do_typ_inv_52 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_54 : Float32.t) (temp___skip_top_level_55 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_54 : Float32.t) (temp___skip_top_level_55 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_54 : Float32.t) (temp___skip_top_level_55 : bool) }

end

(* Module giving axioms for type "float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__float___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Standard__float as Standard__float

 predicate dynamic_invariant [@inline] 
   (temp___expr_60 : Float32.t) (temp___is_init_56 : bool) (temp___skip_constant_57 : bool) (temp___do_toplevel_58 : bool) (temp___do_typ_inv_59 : bool) =
  (if (( temp___is_init_56 \/ (Float32.le Standard__float.first Standard__float.last) )) then (
   (Standard__float.dynamic_property Standard__float.first Standard__float.last temp___expr_60)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_60 : Float32.t) (temp___is_init_56 : bool) (temp___skip_constant_57 : bool) (temp___do_toplevel_58 : bool) (temp___do_typ_inv_59 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_60 : Float32.t) (temp___is_init_56 : bool) (temp___skip_constant_57 : bool) (temp___do_toplevel_58 : bool) (temp___do_typ_inv_59 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_61 : Float32.t) (temp___skip_top_level_62 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_61 : Float32.t) (temp___skip_top_level_62 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_61 : Float32.t) (temp___skip_top_level_62 : bool) }

end

(* Module giving axioms for type "long_float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_float___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float64 as Float64
 use        Standard__long_float as Standard__long_float

 predicate dynamic_invariant [@inline] 
   (temp___expr_67 : Float64.t) (temp___is_init_63 : bool) (temp___skip_constant_64 : bool) (temp___do_toplevel_65 : bool) (temp___do_typ_inv_66 : bool) =
  (if (( temp___is_init_63 \/ (Float64.le Standard__long_float.first Standard__long_float.last) )) then (
   (Standard__long_float.dynamic_property Standard__long_float.first Standard__long_float.last temp___expr_67)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_67 : Float64.t) (temp___is_init_63 : bool) (temp___skip_constant_64 : bool) (temp___do_toplevel_65 : bool) (temp___do_typ_inv_66 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_67 : Float64.t) (temp___is_init_63 : bool) (temp___skip_constant_64 : bool) (temp___do_toplevel_65 : bool) (temp___do_typ_inv_66 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_68 : Float64.t) (temp___skip_top_level_69 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_68 : Float64.t) (temp___skip_top_level_69 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_68 : Float64.t) (temp___skip_top_level_69 : bool) }

end

(* Module giving axioms for type "character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__character___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character

 predicate dynamic_invariant [@inline] 
   (temp___expr_74 : int) (temp___is_init_70 : bool) (temp___skip_constant_71 : bool) (temp___do_toplevel_72 : bool) (temp___do_typ_inv_73 : bool) =
  (if (( temp___is_init_70 \/ (Standard__character.first <= Standard__character.last) )) then (
   (Standard__character.dynamic_property Standard__character.first Standard__character.last temp___expr_74)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_74 : int) (temp___is_init_70 : bool) (temp___skip_constant_71 : bool) (temp___do_toplevel_72 : bool) (temp___do_typ_inv_73 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_74 : int) (temp___is_init_70 : bool) (temp___skip_constant_71 : bool) (temp___do_toplevel_72 : bool) (temp___do_typ_inv_73 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_75 : int) (temp___skip_top_level_76 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_75 : int) (temp___skip_top_level_76 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_75 : int) (temp___skip_top_level_76 : bool) }

end

(* Module giving axioms for type "wide_character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_character___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__wide_character as Standard__wide_character

 predicate dynamic_invariant [@inline] 
   (temp___expr_81 : int) (temp___is_init_77 : bool) (temp___skip_constant_78 : bool) (temp___do_toplevel_79 : bool) (temp___do_typ_inv_80 : bool) =
  (if (( temp___is_init_77 \/ (Standard__wide_character.first <= Standard__wide_character.last) )) then (
   (Standard__wide_character.dynamic_property Standard__wide_character.first Standard__wide_character.last temp___expr_81)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_81 : int) (temp___is_init_77 : bool) (temp___skip_constant_78 : bool) (temp___do_toplevel_79 : bool) (temp___do_typ_inv_80 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_81 : int) (temp___is_init_77 : bool) (temp___skip_constant_78 : bool) (temp___do_toplevel_79 : bool) (temp___do_typ_inv_80 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_82 : int) (temp___skip_top_level_83 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_82 : int) (temp___skip_top_level_83 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_82 : int) (temp___skip_top_level_83 : bool) }

end

(* Module giving axioms for type "wide_wide_character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_wide_character___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__wide_wide_character as Standard__wide_wide_character

 predicate dynamic_invariant [@inline] 
   (temp___expr_88 : int) (temp___is_init_84 : bool) (temp___skip_constant_85 : bool) (temp___do_toplevel_86 : bool) (temp___do_typ_inv_87 : bool) =
  (if (( temp___is_init_84 \/ (Standard__wide_wide_character.first <= Standard__wide_wide_character.last) )) then (
   (Standard__wide_wide_character.dynamic_property Standard__wide_wide_character.first Standard__wide_wide_character.last temp___expr_88)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_88 : int) (temp___is_init_84 : bool) (temp___skip_constant_85 : bool) (temp___do_toplevel_86 : bool) (temp___do_typ_inv_87 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_88 : int) (temp___is_init_84 : bool) (temp___skip_constant_85 : bool) (temp___do_toplevel_86 : bool) (temp___do_typ_inv_87 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_89 : int) (temp___skip_top_level_90 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_89 : int) (temp___skip_top_level_90 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_89 : int) (temp___skip_top_level_90 : bool) }

end

(* Module giving axioms for type "string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__string___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Standard__positive as Standard__positive
 use        Standard__string as Standard__string

 predicate dynamic_invariant [@inline] 
   (temp___expr_96 : Standard__string.string) (temp___is_init_92 : bool) (temp___skip_constant_93 : bool) (temp___do_toplevel_94 : bool) (temp___do_typ_inv_95 : bool) =
  (if (temp___skip_constant_93) then (
   true) else (
   (Standard__string.dynamic_property Standard__positive.first Standard__positive.last (Standard__string.first temp___expr_96) (Standard__string.last temp___expr_96))))
 val dynamic_invariant [@inline] 
   (temp___expr_96 : Standard__string.string) (temp___is_init_92 : bool) (temp___skip_constant_93 : bool) (temp___do_toplevel_94 : bool) (temp___do_typ_inv_95 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_96 : Standard__string.string) (temp___is_init_92 : bool) (temp___skip_constant_93 : bool) (temp___do_toplevel_94 : bool) (temp___do_typ_inv_95 : bool) }

end

(* Module giving axioms for type "wide_string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_string___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Standard__positive as Standard__positive
 use        Standard__wide_string as Standard__wide_string

 predicate dynamic_invariant [@inline] 
   (temp___expr_103 : Standard__wide_string.wide_string) (temp___is_init_99 : bool) (temp___skip_constant_100 : bool) (temp___do_toplevel_101 : bool) (temp___do_typ_inv_102 : bool) =
  (if (temp___skip_constant_100) then (
   true) else (
   (Standard__wide_string.dynamic_property Standard__positive.first Standard__positive.last (Standard__wide_string.first temp___expr_103) (Standard__wide_string.last temp___expr_103))))
 val dynamic_invariant [@inline] 
   (temp___expr_103 : Standard__wide_string.wide_string) (temp___is_init_99 : bool) (temp___skip_constant_100 : bool) (temp___do_toplevel_101 : bool) (temp___do_typ_inv_102 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_103 : Standard__wide_string.wide_string) (temp___is_init_99 : bool) (temp___skip_constant_100 : bool) (temp___do_toplevel_101 : bool) (temp___do_typ_inv_102 : bool) }

end

(* Module giving axioms for type "wide_wide_string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_wide_string___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Standard__positive as Standard__positive
 use        Standard__wide_wide_string as Standard__wide_wide_string

 predicate dynamic_invariant [@inline] 
   (temp___expr_110 : Standard__wide_wide_string.wide_wide_string) (temp___is_init_106 : bool) (temp___skip_constant_107 : bool) (temp___do_toplevel_108 : bool) (temp___do_typ_inv_109 : bool) =
  (if (temp___skip_constant_107) then (
   true) else (
   (Standard__wide_wide_string.dynamic_property Standard__positive.first Standard__positive.last (Standard__wide_wide_string.first temp___expr_110) (Standard__wide_wide_string.last temp___expr_110))))
 val dynamic_invariant [@inline] 
   (temp___expr_110 : Standard__wide_wide_string.wide_wide_string) (temp___is_init_106 : bool) (temp___skip_constant_107 : bool) (temp___do_toplevel_108 : bool) (temp___do_typ_inv_109 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_110 : Standard__wide_wide_string.wide_wide_string) (temp___is_init_106 : bool) (temp___skip_constant_107 : bool) (temp___do_toplevel_108 : bool) (temp___do_typ_inv_109 : bool) }

end

(* Module giving axioms for type "duration", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__duration___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Standard__duration as Standard__duration

 predicate dynamic_invariant [@inline] 
   (temp___expr_116 : Main.__fixed) (temp___is_init_112 : bool) (temp___skip_constant_113 : bool) (temp___do_toplevel_114 : bool) (temp___do_typ_inv_115 : bool) =
  (if (( temp___is_init_112 \/ (Standard__duration.first <= Standard__duration.last) )) then (
   (Standard__duration.dynamic_property Standard__duration.first Standard__duration.last temp___expr_116)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_116 : Main.__fixed) (temp___is_init_112 : bool) (temp___skip_constant_113 : bool) (temp___do_toplevel_114 : bool) (temp___do_typ_inv_115 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_116 : Main.__fixed) (temp___is_init_112 : bool) (temp___skip_constant_113 : bool) (temp___do_toplevel_114 : bool) (temp___do_typ_inv_115 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_117 : Main.__fixed) (temp___skip_top_level_118 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_117 : Main.__fixed) (temp___skip_top_level_118 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_117 : Main.__fixed) (temp___skip_top_level_118 : bool) }

end

(* Module giving axioms for type "integer_8", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_8___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer_8 as Standard__integer_8

 predicate dynamic_invariant [@inline] 
   (temp___expr_123 : int) (temp___is_init_119 : bool) (temp___skip_constant_120 : bool) (temp___do_toplevel_121 : bool) (temp___do_typ_inv_122 : bool) =
  (if (( temp___is_init_119 \/ (Standard__integer_8.first <= Standard__integer_8.last) )) then (
   (Standard__integer_8.dynamic_property Standard__integer_8.first Standard__integer_8.last temp___expr_123)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_123 : int) (temp___is_init_119 : bool) (temp___skip_constant_120 : bool) (temp___do_toplevel_121 : bool) (temp___do_typ_inv_122 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_123 : int) (temp___is_init_119 : bool) (temp___skip_constant_120 : bool) (temp___do_toplevel_121 : bool) (temp___do_typ_inv_122 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_124 : int) (temp___skip_top_level_125 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_124 : int) (temp___skip_top_level_125 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_124 : int) (temp___skip_top_level_125 : bool) }

end

(* Module giving axioms for type "integer_16", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_16___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer_16 as Standard__integer_16

 predicate dynamic_invariant [@inline] 
   (temp___expr_130 : int) (temp___is_init_126 : bool) (temp___skip_constant_127 : bool) (temp___do_toplevel_128 : bool) (temp___do_typ_inv_129 : bool) =
  (if (( temp___is_init_126 \/ (Standard__integer_16.first <= Standard__integer_16.last) )) then (
   (Standard__integer_16.dynamic_property Standard__integer_16.first Standard__integer_16.last temp___expr_130)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_130 : int) (temp___is_init_126 : bool) (temp___skip_constant_127 : bool) (temp___do_toplevel_128 : bool) (temp___do_typ_inv_129 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_130 : int) (temp___is_init_126 : bool) (temp___skip_constant_127 : bool) (temp___do_toplevel_128 : bool) (temp___do_typ_inv_129 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_131 : int) (temp___skip_top_level_132 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_131 : int) (temp___skip_top_level_132 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_131 : int) (temp___skip_top_level_132 : bool) }

end

(* Module giving axioms for type "integer_32", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_32___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer_32 as Standard__integer_32

 predicate dynamic_invariant [@inline] 
   (temp___expr_137 : int) (temp___is_init_133 : bool) (temp___skip_constant_134 : bool) (temp___do_toplevel_135 : bool) (temp___do_typ_inv_136 : bool) =
  (if (( temp___is_init_133 \/ (Standard__integer_32.first <= Standard__integer_32.last) )) then (
   (Standard__integer_32.dynamic_property Standard__integer_32.first Standard__integer_32.last temp___expr_137)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_137 : int) (temp___is_init_133 : bool) (temp___skip_constant_134 : bool) (temp___do_toplevel_135 : bool) (temp___do_typ_inv_136 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_137 : int) (temp___is_init_133 : bool) (temp___skip_constant_134 : bool) (temp___do_toplevel_135 : bool) (temp___do_typ_inv_136 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_138 : int) (temp___skip_top_level_139 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_138 : int) (temp___skip_top_level_139 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_138 : int) (temp___skip_top_level_139 : bool) }

end

(* Module giving axioms for type "integer_64", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_64___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__integer_64 as Standard__integer_64

 predicate dynamic_invariant [@inline] 
   (temp___expr_144 : int) (temp___is_init_140 : bool) (temp___skip_constant_141 : bool) (temp___do_toplevel_142 : bool) (temp___do_typ_inv_143 : bool) =
  (if (( temp___is_init_140 \/ (Standard__integer_64.first <= Standard__integer_64.last) )) then (
   (Standard__integer_64.dynamic_property Standard__integer_64.first Standard__integer_64.last temp___expr_144)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_144 : int) (temp___is_init_140 : bool) (temp___skip_constant_141 : bool) (temp___do_toplevel_142 : bool) (temp___do_typ_inv_143 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_144 : int) (temp___is_init_140 : bool) (temp___skip_constant_141 : bool) (temp___do_toplevel_142 : bool) (temp___do_typ_inv_143 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_145 : int) (temp___skip_top_level_146 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_145 : int) (temp___skip_top_level_146 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_145 : int) (temp___skip_top_level_146 : bool) }

end

(* Module giving axioms for type "universal_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__universal_integer___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__universal_integer as Standard__universal_integer

 predicate dynamic_invariant [@inline] 
   (temp___expr_151 : int) (temp___is_init_147 : bool) (temp___skip_constant_148 : bool) (temp___do_toplevel_149 : bool) (temp___do_typ_inv_150 : bool) =
  (if (( temp___is_init_147 \/ (Standard__universal_integer.first <= Standard__universal_integer.last) )) then (
   (Standard__universal_integer.dynamic_property Standard__universal_integer.first Standard__universal_integer.last temp___expr_151)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_151 : int) (temp___is_init_147 : bool) (temp___skip_constant_148 : bool) (temp___do_toplevel_149 : bool) (temp___do_typ_inv_150 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_151 : int) (temp___is_init_147 : bool) (temp___skip_constant_148 : bool) (temp___do_toplevel_149 : bool) (temp___do_typ_inv_150 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_152 : int) (temp___skip_top_level_153 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_152 : int) (temp___skip_top_level_153 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_152 : int) (temp___skip_top_level_153 : bool) }

end

(* Module for possibly declaring a logic function for "emptycarriage" defined at cw.ads:52, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__emptycarriage
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "unloadcarriage" defined at cw.ads:55, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__unloadcarriage
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "loadcarriage" defined at cw.ads:58, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__loadcarriage
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "loadrod" defined at cw.ads:61, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__loadrod
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "unloadrod" defined at cw.ads:64, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__unloadrod
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "maintenancemodeon" defined at cw.ads:67, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__maintenancemodeon
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "maintenancemodeoff" defined at cw.ads:70, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__maintenancemodeoff
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "updatestats" defined at cw.ads:73, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__updatestats
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "refillwater" defined at cw.ads:76, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__refillwater
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "movetrain" defined at cw.ads:79, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Cw__movetrain
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "line_length__2" defined at a-textio.ads:245, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__text_io__line_length__2
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main

 val function line_length__2 
   (ada__text_io__standard_in : Main.__private) (ada__text_io__file_system : Main.__private) (ada__text_io__standard_out : Main.__private) (ada__text_io__standard_err : Main.__private) (ada__text_io__current_in : Main.__private) (ada__text_io__current_out : Main.__private) (ada__text_io__current_err : Main.__private) : int
 
 val predicate line_length__2__function_guard 
   (temp___result_159 : int) (ada__text_io__standard_in : Main.__private) (ada__text_io__file_system : Main.__private) (ada__text_io__standard_out : Main.__private) (ada__text_io__standard_err : Main.__private) (ada__text_io__current_in : Main.__private) (ada__text_io__current_out : Main.__private) (ada__text_io__current_err : Main.__private)

end

(* Module for possibly declaring a logic function for "page_length__2" defined at a-textio.ads:251, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__text_io__page_length__2
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main

 val function page_length__2 
   (ada__text_io__standard_in : Main.__private) (ada__text_io__file_system : Main.__private) (ada__text_io__standard_out : Main.__private) (ada__text_io__standard_err : Main.__private) (ada__text_io__current_in : Main.__private) (ada__text_io__current_out : Main.__private) (ada__text_io__current_err : Main.__private) : int
 
 val predicate page_length__2__function_guard 
   (temp___result_160 : int) (ada__text_io__standard_in : Main.__private) (ada__text_io__file_system : Main.__private) (ada__text_io__standard_out : Main.__private) (ada__text_io__standard_err : Main.__private) (ada__text_io__current_in : Main.__private) (ada__text_io__current_out : Main.__private) (ada__text_io__current_err : Main.__private)

end

(* Module for defining the loop exit exception for the loop "L_1" defined at cw.adb:7, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Cw__emptycarriage__L_1
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_1

end

(* Module giving an empty axiom for the entity "L_1" defined at cw.adb:7, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__emptycarriage__L_1___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the loop exit exception for the loop "L_2" defined at cw.adb:48, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Cw__maintenancemodeon__L_2
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_2

end

(* Module giving an empty axiom for the entity "L_2" defined at cw.adb:48, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__maintenancemodeon__L_2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the loop exit exception for the loop "L_3" defined at cw.adb:69, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Cw__connectedcarriages__L_3
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_3

end

(* Module giving an empty axiom for the entity "L_3" defined at cw.adb:69, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__connectedcarriages__L_3___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for defining the loop exit exception for the loop "L_4" defined at cw.adb:83, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Cw__loadedrods__L_4
 use        "_gnatprove_standard".Main
 use        "int".Int

 exception L_4

end

(* Module giving an empty axiom for the entity "L_4" defined at cw.adb:83, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Cw__loadedrods__L_4___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "put__4" defined at a-textio.ads:465, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__text_io__put__4
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module for possibly declaring a logic function for "put__2" defined at a-tiflio.ads:82 instantiated at a-flteio.ads:20, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__float_text_io__put__2
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "carriageslot" defined at cw.ads:5, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__carriageslot___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriageslot as Cw__carriageslot

 predicate dynamic_invariant [@inline] 
   (temp___expr_165 : int) (temp___is_init_161 : bool) (temp___skip_constant_162 : bool) (temp___do_toplevel_163 : bool) (temp___do_typ_inv_164 : bool) =
  (if (( temp___is_init_161 \/ (Cw__carriageslot.first <= Cw__carriageslot.last) )) then (
   (Cw__carriageslot.dynamic_property Cw__carriageslot.first Cw__carriageslot.last temp___expr_165)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_165 : int) (temp___is_init_161 : bool) (temp___skip_constant_162 : bool) (temp___do_toplevel_163 : bool) (temp___do_typ_inv_164 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_165 : int) (temp___is_init_161 : bool) (temp___skip_constant_162 : bool) (temp___do_toplevel_163 : bool) (temp___do_typ_inv_164 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_166 : int) (temp___skip_top_level_167 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_166 : int) (temp___skip_top_level_167 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_166 : int) (temp___skip_top_level_167 : bool) }

end

(* Module giving axioms for type "moving" defined at cw.ads:6, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__moving___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__moving as Cw__moving

 predicate dynamic_invariant [@inline] 
   (temp___expr_172 : int) (temp___is_init_168 : bool) (temp___skip_constant_169 : bool) (temp___do_toplevel_170 : bool) (temp___do_typ_inv_171 : bool) =
  (if (( temp___is_init_168 \/ (Cw__moving.first <= Cw__moving.last) )) then (
   (Cw__moving.dynamic_property Cw__moving.first Cw__moving.last temp___expr_172)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_172 : int) (temp___is_init_168 : bool) (temp___skip_constant_169 : bool) (temp___do_toplevel_170 : bool) (temp___do_typ_inv_171 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_172 : int) (temp___is_init_168 : bool) (temp___skip_constant_169 : bool) (temp___do_toplevel_170 : bool) (temp___do_typ_inv_171 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_173 : int) (temp___skip_top_level_174 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_173 : int) (temp___skip_top_level_174 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_173 : int) (temp___skip_top_level_174 : bool) }

end

(* Module giving axioms for type "rod" defined at cw.ads:8, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__rod___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rod as Cw__rod

 predicate dynamic_invariant [@inline] 
   (temp___expr_179 : int) (temp___is_init_175 : bool) (temp___skip_constant_176 : bool) (temp___do_toplevel_177 : bool) (temp___do_typ_inv_178 : bool) =
  (if (( temp___is_init_175 \/ (Cw__rod.first <= Cw__rod.last) )) then (
   (Cw__rod.dynamic_property Cw__rod.first Cw__rod.last temp___expr_179)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_179 : int) (temp___is_init_175 : bool) (temp___skip_constant_176 : bool) (temp___do_toplevel_177 : bool) (temp___do_typ_inv_178 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_179 : int) (temp___is_init_175 : bool) (temp___skip_constant_176 : bool) (temp___do_toplevel_177 : bool) (temp___do_typ_inv_178 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_180 : int) (temp___skip_top_level_181 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_180 : int) (temp___skip_top_level_181 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_180 : int) (temp___skip_top_level_181 : bool) }

end

(* Module giving axioms for type "TenergyB" defined at cw.ads:10, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TenergyB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "energy" defined at cw.ads:10, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__energy___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__energy as Cw__energy

 predicate dynamic_invariant [@inline] 
   (temp___expr_186 : Float32.t) (temp___is_init_182 : bool) (temp___skip_constant_183 : bool) (temp___do_toplevel_184 : bool) (temp___do_typ_inv_185 : bool) =
  (if (( temp___is_init_182 \/ (Float32.le Cw__energy.first Cw__energy.last) )) then (
   (Cw__energy.dynamic_property Cw__energy.first Cw__energy.last temp___expr_186)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_186 : Float32.t) (temp___is_init_182 : bool) (temp___skip_constant_183 : bool) (temp___do_toplevel_184 : bool) (temp___do_typ_inv_185 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_186 : Float32.t) (temp___is_init_182 : bool) (temp___skip_constant_183 : bool) (temp___do_toplevel_184 : bool) (temp___do_typ_inv_185 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_187 : Float32.t) (temp___skip_top_level_188 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_187 : Float32.t) (temp___skip_top_level_188 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_187 : Float32.t) (temp___skip_top_level_188 : bool) }

end

(* Module giving axioms for type "TheatB" defined at cw.ads:11, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TheatB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "heat" defined at cw.ads:11, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__heat___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__heat as Cw__heat

 predicate dynamic_invariant [@inline] 
   (temp___expr_193 : Float32.t) (temp___is_init_189 : bool) (temp___skip_constant_190 : bool) (temp___do_toplevel_191 : bool) (temp___do_typ_inv_192 : bool) =
  (if (( temp___is_init_189 \/ (Float32.le Cw__heat.first Cw__heat.last) )) then (
   (Cw__heat.dynamic_property Cw__heat.first Cw__heat.last temp___expr_193)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_193 : Float32.t) (temp___is_init_189 : bool) (temp___skip_constant_190 : bool) (temp___do_toplevel_191 : bool) (temp___do_typ_inv_192 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_193 : Float32.t) (temp___is_init_189 : bool) (temp___skip_constant_190 : bool) (temp___do_toplevel_191 : bool) (temp___do_typ_inv_192 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_194 : Float32.t) (temp___skip_top_level_195 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_194 : Float32.t) (temp___skip_top_level_195 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_194 : Float32.t) (temp___skip_top_level_195 : bool) }

end

(* Module giving axioms for type "TwaterB" defined at cw.ads:12, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TwaterB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "water" defined at cw.ads:12, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__water___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__water as Cw__water

 predicate dynamic_invariant [@inline] 
   (temp___expr_200 : Float32.t) (temp___is_init_196 : bool) (temp___skip_constant_197 : bool) (temp___do_toplevel_198 : bool) (temp___do_typ_inv_199 : bool) =
  (if (( temp___is_init_196 \/ (Float32.le Cw__water.first Cw__water.last) )) then (
   (Cw__water.dynamic_property Cw__water.first Cw__water.last temp___expr_200)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_200 : Float32.t) (temp___is_init_196 : bool) (temp___skip_constant_197 : bool) (temp___do_toplevel_198 : bool) (temp___do_typ_inv_199 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_200 : Float32.t) (temp___is_init_196 : bool) (temp___skip_constant_197 : bool) (temp___do_toplevel_198 : bool) (temp___do_typ_inv_199 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_201 : Float32.t) (temp___skip_top_level_202 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_201 : Float32.t) (temp___skip_top_level_202 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_201 : Float32.t) (temp___skip_top_level_202 : bool) }

end

(* Module giving axioms for type "TspeedB" defined at cw.ads:13, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TspeedB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "speed" defined at cw.ads:13, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__speed___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__speed as Cw__speed

 predicate dynamic_invariant [@inline] 
   (temp___expr_207 : Float32.t) (temp___is_init_203 : bool) (temp___skip_constant_204 : bool) (temp___do_toplevel_205 : bool) (temp___do_typ_inv_206 : bool) =
  (if (( temp___is_init_203 \/ (Float32.le Cw__speed.first Cw__speed.last) )) then (
   (Cw__speed.dynamic_property Cw__speed.first Cw__speed.last temp___expr_207)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_207 : Float32.t) (temp___is_init_203 : bool) (temp___skip_constant_204 : bool) (temp___do_toplevel_205 : bool) (temp___do_typ_inv_206 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_207 : Float32.t) (temp___is_init_203 : bool) (temp___skip_constant_204 : bool) (temp___do_toplevel_205 : bool) (temp___do_typ_inv_206 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_208 : Float32.t) (temp___skip_top_level_209 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_208 : Float32.t) (temp___skip_top_level_209 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_208 : Float32.t) (temp___skip_top_level_209 : bool) }

end

(* Module giving axioms for type "TcarriagerangeB" defined at cw.ads:15, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TcarriagerangeB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "carriagerange" defined at cw.ads:15, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__carriagerange___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriagerange as Cw__carriagerange

 predicate dynamic_invariant [@inline] 
   (temp___expr_214 : int) (temp___is_init_210 : bool) (temp___skip_constant_211 : bool) (temp___do_toplevel_212 : bool) (temp___do_typ_inv_213 : bool) =
  (if (( temp___is_init_210 \/ (Cw__carriagerange.first <= Cw__carriagerange.last) )) then (
   (Cw__carriagerange.dynamic_property Cw__carriagerange.first Cw__carriagerange.last temp___expr_214)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_214 : int) (temp___is_init_210 : bool) (temp___skip_constant_211 : bool) (temp___do_toplevel_212 : bool) (temp___do_typ_inv_213 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_214 : int) (temp___is_init_210 : bool) (temp___skip_constant_211 : bool) (temp___do_toplevel_212 : bool) (temp___do_typ_inv_213 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_215 : int) (temp___skip_top_level_216 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_215 : int) (temp___skip_top_level_216 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_215 : int) (temp___skip_top_level_216 : bool) }

end

(* Module giving axioms for type "TcarriagecounterB" defined at cw.ads:16, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TcarriagecounterB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "carriagecounter" defined at cw.ads:16, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__carriagecounter___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriagecounter as Cw__carriagecounter

 predicate dynamic_invariant [@inline] 
   (temp___expr_221 : int) (temp___is_init_217 : bool) (temp___skip_constant_218 : bool) (temp___do_toplevel_219 : bool) (temp___do_typ_inv_220 : bool) =
  (if (( temp___is_init_217 \/ (Cw__carriagecounter.first <= Cw__carriagecounter.last) )) then (
   (Cw__carriagecounter.dynamic_property Cw__carriagecounter.first Cw__carriagecounter.last temp___expr_221)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_221 : int) (temp___is_init_217 : bool) (temp___skip_constant_218 : bool) (temp___do_toplevel_219 : bool) (temp___do_typ_inv_220 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_221 : int) (temp___is_init_217 : bool) (temp___skip_constant_218 : bool) (temp___do_toplevel_219 : bool) (temp___do_typ_inv_220 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_222 : int) (temp___skip_top_level_223 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_222 : int) (temp___skip_top_level_223 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_222 : int) (temp___skip_top_level_223 : bool) }

end

(* Module giving axioms for type "TrodrangeB" defined at cw.ads:17, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TrodrangeB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "rodrange" defined at cw.ads:17, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__rodrange___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rodrange as Cw__rodrange

 predicate dynamic_invariant [@inline] 
   (temp___expr_228 : int) (temp___is_init_224 : bool) (temp___skip_constant_225 : bool) (temp___do_toplevel_226 : bool) (temp___do_typ_inv_227 : bool) =
  (if (( temp___is_init_224 \/ (Cw__rodrange.first <= Cw__rodrange.last) )) then (
   (Cw__rodrange.dynamic_property Cw__rodrange.first Cw__rodrange.last temp___expr_228)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_228 : int) (temp___is_init_224 : bool) (temp___skip_constant_225 : bool) (temp___do_toplevel_226 : bool) (temp___do_typ_inv_227 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_228 : int) (temp___is_init_224 : bool) (temp___skip_constant_225 : bool) (temp___do_toplevel_226 : bool) (temp___do_typ_inv_227 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_229 : int) (temp___skip_top_level_230 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_229 : int) (temp___skip_top_level_230 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_229 : int) (temp___skip_top_level_230 : bool) }

end

(* Module giving axioms for type "TrodcounterB" defined at cw.ads:18, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TrodcounterB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "rodcounter" defined at cw.ads:18, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__rodcounter___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__rodcounter as Cw__rodcounter

 predicate dynamic_invariant [@inline] 
   (temp___expr_235 : int) (temp___is_init_231 : bool) (temp___skip_constant_232 : bool) (temp___do_toplevel_233 : bool) (temp___do_typ_inv_234 : bool) =
  (if (( temp___is_init_231 \/ (Cw__rodcounter.first <= Cw__rodcounter.last) )) then (
   (Cw__rodcounter.dynamic_property Cw__rodcounter.first Cw__rodcounter.last temp___expr_235)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_235 : int) (temp___is_init_231 : bool) (temp___skip_constant_232 : bool) (temp___do_toplevel_233 : bool) (temp___do_typ_inv_234 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_235 : int) (temp___is_init_231 : bool) (temp___skip_constant_232 : bool) (temp___do_toplevel_233 : bool) (temp___do_typ_inv_234 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_236 : int) (temp___skip_top_level_237 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_236 : int) (temp___skip_top_level_237 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_236 : int) (temp___skip_top_level_237 : bool) }

end

(* Module giving axioms for type "TincreaserrangeB" defined at cw.ads:19, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TincreaserrangeB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "increaserrange" defined at cw.ads:19, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__increaserrange___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__increaserrange as Cw__increaserrange

 predicate dynamic_invariant [@inline] 
   (temp___expr_242 : int) (temp___is_init_238 : bool) (temp___skip_constant_239 : bool) (temp___do_toplevel_240 : bool) (temp___do_typ_inv_241 : bool) =
  (if (( temp___is_init_238 \/ (Cw__increaserrange.first <= Cw__increaserrange.last) )) then (
   (Cw__increaserrange.dynamic_property Cw__increaserrange.first Cw__increaserrange.last temp___expr_242)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_242 : int) (temp___is_init_238 : bool) (temp___skip_constant_239 : bool) (temp___do_toplevel_240 : bool) (temp___do_typ_inv_241 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_242 : int) (temp___is_init_238 : bool) (temp___skip_constant_239 : bool) (temp___do_toplevel_240 : bool) (temp___do_typ_inv_241 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_243 : int) (temp___skip_top_level_244 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_243 : int) (temp___skip_top_level_244 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_243 : int) (temp___skip_top_level_244 : bool) }

end

(* Module giving axioms for type "TdepleterrangeB" defined at cw.ads:20, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TdepleterrangeB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "depleterrange" defined at cw.ads:20, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__depleterrange___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__depleterrange as Cw__depleterrange

 predicate dynamic_invariant [@inline] 
   (temp___expr_249 : int) (temp___is_init_245 : bool) (temp___skip_constant_246 : bool) (temp___do_toplevel_247 : bool) (temp___do_typ_inv_248 : bool) =
  (if (( temp___is_init_245 \/ (Cw__depleterrange.first <= Cw__depleterrange.last) )) then (
   (Cw__depleterrange.dynamic_property Cw__depleterrange.first Cw__depleterrange.last temp___expr_249)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_249 : int) (temp___is_init_245 : bool) (temp___skip_constant_246 : bool) (temp___do_toplevel_247 : bool) (temp___do_typ_inv_248 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_249 : int) (temp___is_init_245 : bool) (temp___skip_constant_246 : bool) (temp___do_toplevel_247 : bool) (temp___do_typ_inv_248 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_250 : int) (temp___skip_top_level_251 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_250 : int) (temp___skip_top_level_251 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_250 : int) (temp___skip_top_level_251 : bool) }

end

(* Module giving axioms for type "TcarriagearrB" defined at cw.ads:22, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TcarriagearrB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "carriagearr" defined at cw.ads:22, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__carriagearr___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 predicate dynamic_invariant [@inline] 
   (temp___expr_256 : Array__Int__Cw__carriageslot.map) (temp___is_init_252 : bool) (temp___skip_constant_253 : bool) (temp___do_toplevel_254 : bool) (temp___do_typ_inv_255 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_256 : Array__Int__Cw__carriageslot.map) (temp___is_init_252 : bool) (temp___skip_constant_253 : bool) (temp___do_toplevel_254 : bool) (temp___do_typ_inv_255 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_256 : Array__Int__Cw__carriageslot.map) (temp___is_init_252 : bool) (temp___skip_constant_253 : bool) (temp___do_toplevel_254 : bool) (temp___do_typ_inv_255 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_258 : Array__Int__Cw__carriageslot.map) (temp___skip_top_level_259 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_258 : Array__Int__Cw__carriageslot.map) (temp___skip_top_level_259 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_258 : Array__Int__Cw__carriageslot.map) (temp___skip_top_level_259 : bool) }

end

(* Module giving axioms for type "TreactorarrB" defined at cw.ads:23, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__TreactorarrB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "reactorarr" defined at cw.ads:23, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__reactorarr___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 predicate dynamic_invariant [@inline] 
   (temp___expr_266 : Array__Int__Cw__rod.map) (temp___is_init_262 : bool) (temp___skip_constant_263 : bool) (temp___do_toplevel_264 : bool) (temp___do_typ_inv_265 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_266 : Array__Int__Cw__rod.map) (temp___is_init_262 : bool) (temp___skip_constant_263 : bool) (temp___do_toplevel_264 : bool) (temp___do_typ_inv_265 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_266 : Array__Int__Cw__rod.map) (temp___is_init_262 : bool) (temp___skip_constant_263 : bool) (temp___do_toplevel_264 : bool) (temp___do_typ_inv_265 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_268 : Array__Int__Cw__rod.map) (temp___skip_top_level_269 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_268 : Array__Int__Cw__rod.map) (temp___skip_top_level_269 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_268 : Array__Int__Cw__rod.map) (temp___skip_top_level_269 : bool) }

end

(* Module giving axioms for type "trainrecord" defined at cw.ads:27, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__trainrecord___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__trainrecord as Cw__trainrecord

 predicate dynamic_invariant [@inline] 
   (temp___expr_276 : Cw__trainrecord.trainrecord) (temp___is_init_272 : bool) (temp___skip_constant_273 : bool) (temp___do_toplevel_274 : bool) (temp___do_typ_inv_275 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_276 : Cw__trainrecord.trainrecord) (temp___is_init_272 : bool) (temp___skip_constant_273 : bool) (temp___do_toplevel_274 : bool) (temp___do_typ_inv_275 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_276 : Cw__trainrecord.trainrecord) (temp___is_init_272 : bool) (temp___skip_constant_273 : bool) (temp___do_toplevel_274 : bool) (temp___do_typ_inv_275 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_277 : Cw__trainrecord.trainrecord) (temp___skip_top_level_278 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_277 : Cw__trainrecord.trainrecord) (temp___skip_top_level_278 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_277 : Cw__trainrecord.trainrecord) (temp___skip_top_level_278 : bool) }

end

(* Module giving axioms for type "traincarriage" defined at cw.ads:40, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__traincarriage___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Cw__traincarriage as Cw__traincarriage

 predicate dynamic_invariant [@inline] 
   (temp___expr_289 : Cw__traincarriage.traincarriage) (temp___is_init_285 : bool) (temp___skip_constant_286 : bool) (temp___do_toplevel_287 : bool) (temp___do_typ_inv_288 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_289 : Cw__traincarriage.traincarriage) (temp___is_init_285 : bool) (temp___skip_constant_286 : bool) (temp___do_toplevel_287 : bool) (temp___do_typ_inv_288 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_289 : Cw__traincarriage.traincarriage) (temp___is_init_285 : bool) (temp___skip_constant_286 : bool) (temp___do_toplevel_287 : bool) (temp___do_typ_inv_288 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_291 : Cw__traincarriage.traincarriage) (temp___skip_top_level_292 : bool) =
  (if ((Cw__traincarriage.cw__traincarriage__top__pred temp___expr_291)) then (
   ((Cw__carriagerange__rep.to_rep temp___expr_291.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = (0 : int))) else true)
 val default_initial_assumption [@inline] 
   (temp___expr_291 : Cw__traincarriage.traincarriage) (temp___skip_top_level_292 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_291 : Cw__traincarriage.traincarriage) (temp___skip_top_level_292 : bool) }

end

(* Module giving axioms for type "train" defined at cw.ads:45, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__train___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Cw__traincarriage as Cw__traincarriage

 predicate dynamic_invariant [@inline] 
   (temp___expr_300 : Cw__train.train) (temp___is_init_296 : bool) (temp___skip_constant_297 : bool) (temp___do_toplevel_298 : bool) (temp___do_typ_inv_299 : bool) =
  true
 val dynamic_invariant [@inline] 
   (temp___expr_300 : Cw__train.train) (temp___is_init_296 : bool) (temp___skip_constant_297 : bool) (temp___do_toplevel_298 : bool) (temp___do_typ_inv_299 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_300 : Cw__train.train) (temp___is_init_296 : bool) (temp___skip_constant_297 : bool) (temp___do_toplevel_298 : bool) (temp___do_typ_inv_299 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_303 : Cw__train.train) (temp___skip_top_level_304 : bool) =
  (if ((Cw__train.cw__train__carriage__pred temp___expr_303)) then (
   (let temp___313 [@mlw:proxy_symbol] [@introduced] = temp___expr_303.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
    (if ((Cw__traincarriage.cw__traincarriage__top__pred temp___expr_303.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage)) then (
     ((Cw__carriagerange__rep.to_rep temp___expr_303.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = (0 : int))) else true)))
  ) else true)
 val default_initial_assumption [@inline] 
   (temp___expr_303 : Cw__train.train) (temp___skip_top_level_304 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_303 : Cw__train.train) (temp___skip_top_level_304 : bool) }

end

(* Module giving axioms for type "T26s" defined at cw.ads:54, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__emptycarriage__L25s__T26s___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T28s" defined at cw.ads:69, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__maintenancemodeon__L27s__T28s___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "TcountB" defined at a-textio.ads:77, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__text_io__TcountB___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "count" defined at a-textio.ads:77, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__text_io__count___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Ada__text_io__count as Ada__text_io__count

 predicate dynamic_invariant [@inline] 
   (temp___expr_391 : int) (temp___is_init_387 : bool) (temp___skip_constant_388 : bool) (temp___do_toplevel_389 : bool) (temp___do_typ_inv_390 : bool) =
  (if (( temp___is_init_387 \/ (Ada__text_io__count.first <= Ada__text_io__count.last) )) then (
   (Ada__text_io__count.dynamic_property Ada__text_io__count.first Ada__text_io__count.last temp___expr_391)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_391 : int) (temp___is_init_387 : bool) (temp___skip_constant_388 : bool) (temp___do_toplevel_389 : bool) (temp___do_typ_inv_390 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_391 : int) (temp___is_init_387 : bool) (temp___skip_constant_388 : bool) (temp___do_toplevel_389 : bool) (temp___do_typ_inv_390 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_392 : int) (temp___skip_top_level_393 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_392 : int) (temp___skip_top_level_393 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_392 : int) (temp___skip_top_level_393 : bool) }

end

(* Module giving axioms for type "T1b" defined at cw.adb:7, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__emptycarriage__L_1__T1b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T5b" defined at cw.adb:9, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__emptycarriage__L_1__L4b__T5b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T3b" defined at cw.adb:9, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__emptycarriage__L_1__L2b__T3b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T6b" defined at cw.adb:48, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__maintenancemodeon__L_2__T6b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T10b" defined at cw.adb:50, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__maintenancemodeon__L_2__L9b__T10b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T8b" defined at cw.adb:50, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__maintenancemodeon__L_2__L7b__T8b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T11b" defined at cw.adb:69, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__connectedcarriages__L_3__T11b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T13b" defined at cw.adb:83, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__loadedrods__L_4__T13b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "T15b" defined at cw.adb:137, created in Gnat2Why.Types.Generate_Type_Completion *)
module Cw__movetrain__T15b___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int


end

(* Module giving axioms for type "field" defined at a-textio.ads:86, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__text_io__field___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Ada__text_io__field as Ada__text_io__field

 predicate dynamic_invariant [@inline] 
   (temp___expr_399 : int) (temp___is_init_395 : bool) (temp___skip_constant_396 : bool) (temp___do_toplevel_397 : bool) (temp___do_typ_inv_398 : bool) =
  (if (( temp___is_init_395 \/ (Ada__text_io__field.first <= Ada__text_io__field.last) )) then (
   (Ada__text_io__field.dynamic_property Ada__text_io__field.first Ada__text_io__field.last temp___expr_399)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_399 : int) (temp___is_init_395 : bool) (temp___skip_constant_396 : bool) (temp___do_toplevel_397 : bool) (temp___do_typ_inv_398 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_399 : int) (temp___is_init_395 : bool) (temp___skip_constant_396 : bool) (temp___do_toplevel_397 : bool) (temp___do_typ_inv_398 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_400 : int) (temp___skip_top_level_401 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_400 : int) (temp___skip_top_level_401 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_400 : int) (temp___skip_top_level_401 : bool) }

end

(* Module giving axioms for type "num" defined at a-tiflio.ads:44 instantiated at a-flteio.ads:20, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__float_text_io__num___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Ada__float_text_io__num as Ada__float_text_io__num

 predicate dynamic_invariant [@inline] 
   (temp___expr_406 : Float32.t) (temp___is_init_402 : bool) (temp___skip_constant_403 : bool) (temp___do_toplevel_404 : bool) (temp___do_typ_inv_405 : bool) =
  (if (( temp___is_init_402 \/ (Float32.le Ada__float_text_io__num.first Ada__float_text_io__num.last) )) then (
   (Ada__float_text_io__num.dynamic_property Ada__float_text_io__num.first Ada__float_text_io__num.last temp___expr_406)) else true)
 val dynamic_invariant [@inline] 
   (temp___expr_406 : Float32.t) (temp___is_init_402 : bool) (temp___skip_constant_403 : bool) (temp___do_toplevel_404 : bool) (temp___do_typ_inv_405 : bool) : bool
  ensures { result <-> dynamic_invariant (temp___expr_406 : Float32.t) (temp___is_init_402 : bool) (temp___skip_constant_403 : bool) (temp___do_toplevel_404 : bool) (temp___do_typ_inv_405 : bool) }
 
 predicate default_initial_assumption [@inline] 
   (temp___expr_407 : Float32.t) (temp___skip_top_level_408 : bool) =
  true
 val default_initial_assumption [@inline] 
   (temp___expr_407 : Float32.t) (temp___skip_top_level_408 : bool) : bool
  ensures { result <-> default_initial_assumption (temp___expr_407 : Float32.t) (temp___skip_top_level_408 : bool) }

end

(* Module for defining a value for string literal  defined at cw.adb:137, created in Gnat2Why.Expr.Transform_String_Literal *)
module Temp___String_Literal_567
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Standard__character as Standard__character
 use        Standard__character__rep as Standard__character__rep
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character

 val function temp___String_Literal_567 
   (__void_param : unit) : Array__Int__Standard__character.map
 
 axiom temp___String_Literal_567__def_axiom :
  (forall __void_param   : unit [(temp___String_Literal_567 __void_param)].
   ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (1 : int))) = (68 : int)) /\ ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (2 : int))) = (105 : int)) )/\( ( ( ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (3 : int))) = (115 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (4 : int))) = (116 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (5 : int))) = (97 : int)) )/\( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (6 : int))) = (110 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (7 : int))) = (99 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (8 : int))) = (101 : int)) ) )/\( ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (9 : int))) = (32 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (10 : int))) = (116 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (11 : int))) = (114 : int)) )/\( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (12 : int))) = (97 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (13 : int))) = (118 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (14 : int))) = (101 : int)) ) ) )/\( ( ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (15 : int))) = (108 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (16 : int))) = (108 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (17 : int))) = (101 : int)) )/\( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (18 : int))) = (100 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (19 : int))) = (32 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (20 : int))) = (40 : int)) ) )/\( ( ( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (21 : int))) = (107 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (22 : int))) = (109 : int)) )/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (23 : int))) = (41 : int)) )/\( ((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (24 : int))) = (58 : int))/\((Standard__character__rep.to_rep (Array__Int__Standard__character.get (temp___String_Literal_567 __void_param) (25 : int))) = (32 : int)) ) ) ) ) ))

end
(* Module for defining the value of constant "speedmultiplier" defined at cw.ads:25, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Cw__speedmultiplier___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__speedmultiplier as Cw__speedmultiplier

 axiom speedmultiplier__def_axiom :
  ((Cw__speedmultiplier.speedmultiplier ) = (5.0:Float32.t))

end

(* Module giving a program function and a defining axiom for the expression function "istrainmoving" defined at cw.ads:85, created in Gnat2Why.Subprograms.Translate_Expression_Function_Body *)
module Cw__istrainmoving___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep

 val istrainmoving 
   (t : Cw__train.train) : bool
  requires {  true }
  ensures {  ( ( (result = (Cw__istrainmoving.istrainmoving t)) /\ (Cw__istrainmoving.istrainmoving__function_guard result t) )/\( (result = True) <-> ((Cw__moving__rep.to_rep t.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (0 : int)) ) ) }
 
 axiom istrainmoving__post_axiom :
  (forall t   : Cw__train.train [(Cw__istrainmoving.istrainmoving t)].
   ( (Cw__train___axiom.dynamic_invariant t True True True True) -> (let result = (Cw__istrainmoving.istrainmoving t) in (
    (if ((Cw__istrainmoving.istrainmoving__function_guard result t)) then (
     ( ( true /\ true )/\true )) else true)))
    ))
 
 axiom istrainmoving__def_axiom :
  (forall t   : Cw__train.train [(Cw__istrainmoving.istrainmoving t)].
   ( (let result = (Cw__istrainmoving.istrainmoving t) in (
    (Cw__istrainmoving.istrainmoving__function_guard result t)))
    -> ( ((Cw__istrainmoving.istrainmoving t) = True) <-> ((Cw__moving__rep.to_rep t.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (0 : int)) ) ))

end

(* Module for declaring a program function (and possibly an axiom) for "emptycarriage" defined at cw.ads:52, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__emptycarriage___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__traincarriage as Cw__traincarriage
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 val emptycarriage 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( ( [@GP_Pretty_Ada:3737] ( ((epsilon temp___result_324 : bool.
   ( (temp___result_324 = (Cw__istrainmoving.istrainmoving { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__istrainmoving.istrainmoving__function_guard temp___result_324 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) = True) <-> false ) ) /\ ( [@GP_Pretty_Ada:3745] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) > (0 : int)) ) ) }
  ensures {  ( ( ( [@GP_Pretty_Ada:3755] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = (0 : int)) ) /\ (forall j   [@model_trace:3760] [@name:J]  : int.
   ( ( ((0 : int) <= j) /\ (j <= (10 : int)) ) -> ( [@GP_Pretty_Ada:3791] ((Cw__carriageslot__rep.to_rep (let temp___325 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
    (Array__Int__Cw__carriageslot.get temp___325 j)))
   ) <> (1 : int)) ) )) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "unloadcarriage" defined at cw.ads:55, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__unloadcarriage___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__traincarriage as Cw__traincarriage
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 val unloadcarriage 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( ( [@GP_Pretty_Ada:3818] ( ((epsilon temp___result_330 : bool.
   ( (temp___result_330 = (Cw__istrainmoving.istrainmoving { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__istrainmoving.istrainmoving__function_guard temp___result_330 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) = True) <-> false ) ) /\ ( [@GP_Pretty_Ada:3826] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) > (0 : int)) ) ) }
  ensures {  ( ( ( [@GP_Pretty_Ada:3836] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = ((Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )) - (1 : int))) ) /\ ( [@GP_Pretty_Ada:3862] ((Cw__carriageslot__rep.to_rep (let temp___331 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
   (Array__Int__Cw__carriageslot.get temp___331 ((Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )) - (1 : int)))))
  ) = (0 : int)) ) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "loadcarriage" defined at cw.ads:58, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__loadcarriage___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__traincarriage as Cw__traincarriage
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot

 val loadcarriage 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( ( [@GP_Pretty_Ada:3889] ( ((epsilon temp___result_336 : bool.
   ( (temp___result_336 = (Cw__istrainmoving.istrainmoving { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__istrainmoving.istrainmoving__function_guard temp___result_336 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) = True) <-> false ) ) /\ ( [@GP_Pretty_Ada:3897] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) < (10 : int)) ) ) }
  ensures {  ( ( ( [@GP_Pretty_Ada:3909] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = ((Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )) + (1 : int))) ) /\ ( [@GP_Pretty_Ada:3933] ((Cw__carriageslot__rep.to_rep (let temp___337 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
   (Array__Int__Cw__carriageslot.get temp___337 (Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )))))
  ) = (1 : int)) ) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "loadedrods" defined at cw.ads:83, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__loadedrods___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom

 val loadedrods 
   (t : Cw__train.train) : int
  requires {  true }
  ensures {  ( ( (result = (Cw__loadedrods.loadedrods t)) /\ (Cw__loadedrods.loadedrods__function_guard result t) )/\(Cw__rodcounter___axiom.dynamic_invariant result True False True True) ) }
 
 axiom loadedrods__post_axiom :
  (forall t   : Cw__train.train [(Cw__loadedrods.loadedrods t)].
   ( (Cw__train___axiom.dynamic_invariant t True True True True) -> (let result = (Cw__loadedrods.loadedrods t) in (
    (if ((Cw__loadedrods.loadedrods__function_guard result t)) then (
     ( ( true /\ (Cw__rodcounter___axiom.dynamic_invariant result True False True True) )/\true )) else true)))
    ))

end

(* Module for declaring a program function (and possibly an axiom) for "loadrod" defined at cw.ads:61, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__loadrod___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 val loadrod 
   (t__split_fields : Cw__train.__split_fields__ref) (n : int) : unit
  requires {  ( ( ( ( ( [@GP_Pretty_Ada:3967] (n >= (1 : int)) ) /\ ( [@GP_Pretty_Ada:3975] (n <= (4 : int)) ) ) /\ ( [@GP_Pretty_Ada:3983] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) ) /\ ( [@GP_Pretty_Ada:3989] ((epsilon temp___result_346 : int.
   ( (temp___result_346 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_346 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) < (5 : int)) ) ) /\ ( [@GP_Pretty_Ada:3999] ((Cw__rod__rep.to_rep (let temp___347 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___347 n)))
  ) = (0 : int)) ) ) }
  ensures {  ( ( [@GP_Pretty_Ada:21826] ((Cw__rod__rep.to_rep (let temp___348 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___348 n)))
  ) = (1 : int)) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "unloadrod" defined at cw.ads:64, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__unloadrod___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 val unloadrod 
   (t__split_fields : Cw__train.__split_fields__ref) (n : int) : unit
  requires {  ( ( ( ( ( [@GP_Pretty_Ada:4043] (n >= (1 : int)) ) /\ ( [@GP_Pretty_Ada:4051] (n <= (4 : int)) ) ) /\ ( [@GP_Pretty_Ada:4059] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) ) /\ ( [@GP_Pretty_Ada:4065] ((epsilon temp___result_353 : int.
   ( (temp___result_353 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_353 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) > (1 : int)) ) ) /\ ( [@GP_Pretty_Ada:4077] ((Cw__rod__rep.to_rep (let temp___354 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___354 n)))
  ) = (1 : int)) ) ) }
  ensures {  ( ( [@GP_Pretty_Ada:21896] ((Cw__rod__rep.to_rep (let temp___355 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___355 n)))
  ) = (0 : int)) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "maintenancemodeon" defined at cw.ads:67, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__maintenancemodeon___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod

 val maintenancemodeon 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( [@GP_Pretty_Ada:21923] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) }
  ensures {  ( ( ( [@GP_Pretty_Ada:4121] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (2 : int)) ) /\ (forall j   [@model_trace:4124] [@name:J]  : int.
   ( ( ((0 : int) <= j) /\ (j <= (4 : int)) ) -> ( [@GP_Pretty_Ada:4149] ((Cw__rod__rep.to_rep (let temp___360 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
    (Array__Int__Cw__rod.get temp___360 j)))
   ) <> (0 : int)) ) )) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "maintenancemodeoff" defined at cw.ads:70, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__maintenancemodeoff___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep

 val maintenancemodeoff 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( [@GP_Pretty_Ada:21981] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (2 : int)) ) }
  ensures {  ( ( [@GP_Pretty_Ada:21993] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "updatestats" defined at cw.ads:73, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__updatestats___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__heat as Cw__heat
 use        Cw__heat__rep as Cw__heat__rep
 use        Cw__increaserrange as Cw__increaserrange
 use        Cw__increaserrange__rep as Cw__increaserrange__rep
 use        Cw__depleterrange as Cw__depleterrange
 use        Cw__depleterrange__rep as Cw__depleterrange__rep
 use        Cw__trainrecord as Cw__trainrecord

 val updatestats 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( ( ( [@GP_Pretty_Ada:4210] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) /\ ( [@GP_Pretty_Ada:4216] ((epsilon temp___result_369 : int.
   ( (temp___result_369 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_369 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) > (0 : int)) ) ) /\ ( [@GP_Pretty_Ada:4220] true ) ) }
  ensures {  ( ( ( ( [@GP_Pretty_Ada:4230] (Float32.gt (Cw__heat__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__temperature) (0.0E-1:Float32.t)) ) /\ ( [@GP_Pretty_Ada:4238] ((Cw__increaserrange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__tempincreaser) > (0 : int)) ) ) /\ ( [@GP_Pretty_Ada:4246] ((Cw__depleterrange__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__waterdepletion) > (0 : int)) ) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "refillwater" defined at cw.ads:76, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__refillwater___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__water as Cw__water
 use        Cw__water__rep as Cw__water__rep
 use        Cw__trainrecord as Cw__trainrecord

 val refillwater 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( [@GP_Pretty_Ada:22087] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) }
  ensures {  ( ( [@GP_Pretty_Ada:22102] (Float32.eq (Cw__water__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank) (100.0:Float32.t)) ) /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) ) }
  writes {t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "movetrain" defined at cw.ads:79, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__movetrain___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err

 val movetrain 
   (t__split_fields : Cw__train.__split_fields__ref) : unit
  requires {  ( ( [@GP_Pretty_Ada:4311] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) /\ ( [@GP_Pretty_Ada:4317] ((epsilon temp___result_378 : int.
   ( (temp___result_378 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_378 { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content }) )) > (0 : int)) ) ) }
  ensures {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = t__split_fields.Cw__train.__split_fields__content } True True True True) }
  reads {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}
  writes {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err, t__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "connectedcarriages" defined at cw.ads:82, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Cw__connectedcarriages___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__connectedcarriages as Cw__connectedcarriages
 use        Cw__carriagecounter___axiom as Cw__carriagecounter___axiom

 val connectedcarriages 
   (t : Cw__train.train) : int
  requires {  true }
  ensures {  ( ( (result = (Cw__connectedcarriages.connectedcarriages t)) /\ (Cw__connectedcarriages.connectedcarriages__function_guard result t) )/\(Cw__carriagecounter___axiom.dynamic_invariant result True False True True) ) }
 
 axiom connectedcarriages__post_axiom :
  (forall t   : Cw__train.train [(Cw__connectedcarriages.connectedcarriages t)].
   ( (Cw__train___axiom.dynamic_invariant t True True True True) -> (let result = (Cw__connectedcarriages.connectedcarriages t) in (
    (if ((Cw__connectedcarriages.connectedcarriages__function_guard result t)) then (
     ( ( true /\ (Cw__carriagecounter___axiom.dynamic_invariant result True False True True) )/\true )) else true)))
    ))

end

(* Module for declaring a program function (and possibly an axiom) for "line_length__2" defined at a-textio.ads:245, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__text_io__line_length__2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Ada__text_io__line_length__2 as Ada__text_io__line_length__2
 use        Ada__text_io__count___axiom as Ada__text_io__count___axiom
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err

 val line_length__2 
   (__void_param : unit) : int
  requires {  true }
  ensures {  ( ( (result = (Ada__text_io__line_length__2.line_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content)) /\ true )/\(Ada__text_io__count___axiom.dynamic_invariant result True False True True) ) }
  reads {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}
 
 axiom line_length__2__post_axiom :
  (forall ada__text_io__standard_in   ada__text_io__file_system   ada__text_io__standard_out   ada__text_io__standard_err   ada__text_io__current_in   ada__text_io__current_out   ada__text_io__current_err   : Main.__private [(Ada__text_io__line_length__2.line_length__2 ada__text_io__standard_in ada__text_io__file_system ada__text_io__standard_out ada__text_io__standard_err ada__text_io__current_in ada__text_io__current_out ada__text_io__current_err)].
   ( true -> (let result = (Ada__text_io__line_length__2.line_length__2 ada__text_io__standard_in ada__text_io__file_system ada__text_io__standard_out ada__text_io__standard_err ada__text_io__current_in ada__text_io__current_out ada__text_io__current_err) in (
    ( ( true /\ (Ada__text_io__count___axiom.dynamic_invariant result True False True True) )/\true )))
    ))

end

(* Module for declaring a program function (and possibly an axiom) for "page_length__2" defined at a-textio.ads:251, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__text_io__page_length__2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Ada__text_io__page_length__2 as Ada__text_io__page_length__2
 use        Ada__text_io__count___axiom as Ada__text_io__count___axiom
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err

 val page_length__2 
   (__void_param : unit) : int
  requires {  true }
  ensures {  ( ( (result = (Ada__text_io__page_length__2.page_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content)) /\ true )/\(Ada__text_io__count___axiom.dynamic_invariant result True False True True) ) }
  reads {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}
 
 axiom page_length__2__post_axiom :
  (forall ada__text_io__standard_in   ada__text_io__file_system   ada__text_io__standard_out   ada__text_io__standard_err   ada__text_io__current_in   ada__text_io__current_out   ada__text_io__current_err   : Main.__private [(Ada__text_io__page_length__2.page_length__2 ada__text_io__standard_in ada__text_io__file_system ada__text_io__standard_out ada__text_io__standard_err ada__text_io__current_in ada__text_io__current_out ada__text_io__current_err)].
   ( true -> (let result = (Ada__text_io__page_length__2.page_length__2 ada__text_io__standard_in ada__text_io__file_system ada__text_io__standard_out ada__text_io__standard_err ada__text_io__current_in ada__text_io__current_out ada__text_io__current_err) in (
    ( ( true /\ (Ada__text_io__count___axiom.dynamic_invariant result True False True True) )/\true )))
    ))

end

(* Module for declaring a program function (and possibly an axiom) for "put__4" defined at a-textio.ads:465, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__text_io__put__4___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Standard__string as Standard__string
 use        Ada__text_io__line_length__2 as Ada__text_io__line_length__2
 use        Ada__text_io__page_length__2 as Ada__text_io__page_length__2
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err

 val put__4 
   (item : Standard__string.string) : unit
  requires {  true }
  ensures {  ( ( [@GP_Pretty_Ada:7435] ((old (Ada__text_io__line_length__2.line_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content) ) = (Ada__text_io__line_length__2.line_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content)) ) /\ ( [@GP_Pretty_Ada:7441] ((old (Ada__text_io__page_length__2.page_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content) ) = (Ada__text_io__page_length__2.page_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content)) ) ) }
  reads {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}
  writes {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}

end

(* Module for declaring a program function (and possibly an axiom) for "put__2" defined at a-tiflio.ads:82 instantiated at a-flteio.ads:20, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__float_text_io__put__2___axiom
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Float32 as Float32
 use        Ada__text_io__line_length__2 as Ada__text_io__line_length__2
 use        Ada__text_io__page_length__2 as Ada__text_io__page_length__2
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err

 val put__2 
   (item : Float32.t) (fore : int) (aft : int) (exp : int) : unit
  requires {  true }
  ensures {  ( ( [@GP_Pretty_Ada:20972] ((old (Ada__text_io__line_length__2.line_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content) ) = (Ada__text_io__line_length__2.line_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content)) ) /\ ( [@GP_Pretty_Ada:20976] ((old (Ada__text_io__page_length__2.page_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content) ) = (Ada__text_io__page_length__2.page_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content)) ) ) }
  reads {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}
  writes {Ada__text_io__standard_in.standard_in, Ada__text_io__file_system.file_system, Ada__text_io__standard_out.standard_out, Ada__text_io__standard_err.standard_err, Ada__text_io__current_in.current_in, Ada__text_io__current_out.current_out, Ada__text_io__current_err.current_err}

end

(* Module for checking absence of run-time errors and package initial condition on package elaboration of "cw" defined at cw.ads:1, created in Gnat2Why.Subprograms.Generate_VCs_For_Package_Elaboration *)
module Cw__package_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Float32 as Float32
 use        Standard__float___axiom as Standard__float___axiom
 use        Cw__speedmultiplier as Cw__speedmultiplier
 use        Ada__text_io__line_length__2 as Ada__text_io__line_length__2
 use        Ada__text_io__page_length__2 as Ada__text_io__page_length__2
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Ada__text_io__standard_in as Ada__text_io__standard_in
 use        Ada__text_io__file_system as Ada__text_io__file_system
 use        Ada__text_io__standard_out as Ada__text_io__standard_out
 use        Ada__text_io__standard_err as Ada__text_io__standard_err
 use        Ada__text_io__current_in as Ada__text_io__current_in
 use        Ada__text_io__current_out as Ada__text_io__current_out
 use        Ada__text_io__current_err as Ada__text_io__current_err
 use        Standard__float___axiom as Standard__float___axiom
 use        Cw__speedmultiplier___axiom as Cw__speedmultiplier___axiom
 use        Ada__text_io__count___axiom as Ada__text_io__count___axiom
 use        Ada__text_io__line_length__2___axiom as Ada__text_io__line_length__2___axiom
 use        Ada__text_io__page_length__2___axiom as Ada__text_io__page_length__2___axiom

 let def [#"cw.ads" 1 0 0][@GP_Subp:cw.ads:1] 
   (__void_param : unit)
  requires { [#"cw.ads" 1 0 0] true }
   = [@vc:divergent]
  ( ();
  ([#"cw.ads" 1 0 0] ());
  ([#"cw.ads" 5 0 0] ());
  ([#"cw.ads" 6 0 0] ());
  ([#"cw.ads" 8 0 0] ());
  ([#"cw.ads" 10 0 0] ());
  ([#"cw.ads" 10 0 0] ());
  ([#"cw.ads" 11 0 0] ());
  ([#"cw.ads" 11 0 0] ());
  ([#"cw.ads" 12 0 0] ());
  ([#"cw.ads" 12 0 0] ());
  ([#"cw.ads" 13 0 0] ());
  ([#"cw.ads" 13 0 0] ());
  ([#"cw.ads" 15 0 0] ());
  ([#"cw.ads" 16 0 0] ());
  ([#"cw.ads" 17 0 0] ());
  ([#"cw.ads" 18 0 0] ());
  ([#"cw.ads" 19 0 0] ());
  ([#"cw.ads" 20 0 0] ());
  ([#"cw.ads" 22 0 0] ());
  ([#"cw.ads" 23 0 0] ());
  ([#"cw.ads" 25 0 0] ( [#"cw.ads" 25 0 0] begin ensures {true} let _ = (let _ = (5.0:Float32.t) in (
   ()))
   in () end ;
  [#"cw.ads" 25 0 0] assume { [#"cw.ads" 25 0 0] (Standard__float___axiom.dynamic_invariant Cw__speedmultiplier.speedmultiplier True False True True) } ));
  ([#"cw.ads" 27 0 0] ());
  ([#"cw.ads" 42 0 0] ());
  ([#"cw.ads" 42 0 0] ());
  ([#"cw.ads" 40 0 0] ());
  ([#"cw.ads" 45 0 0] ());
  ([#"cw.ads" 52 0 0] ());
  ([#"cw.ads" 54 0 0] ());
  ([#"cw.ads" 53 0 0] ());
  ([#"cw.ads" 55 0 0] ());
  ([#"cw.ads" 57 0 0] ());
  ([#"cw.ads" 56 0 0] ());
  ([#"cw.ads" 58 0 0] ());
  ([#"cw.ads" 60 0 0] ());
  ([#"cw.ads" 59 0 0] ());
  ([#"cw.ads" 61 0 0] ());
  ([#"cw.ads" 63 0 0] ());
  ([#"cw.ads" 62 0 0] ());
  ([#"cw.ads" 64 0 0] ());
  ([#"cw.ads" 66 0 0] ());
  ([#"cw.ads" 65 0 0] ());
  ([#"cw.ads" 67 0 0] ());
  ([#"cw.ads" 69 0 0] ());
  ([#"cw.ads" 68 0 0] ());
  ([#"cw.ads" 70 0 0] ());
  ([#"cw.ads" 72 0 0] ());
  ([#"cw.ads" 71 0 0] ());
  ([#"cw.ads" 73 0 0] ());
  ([#"cw.ads" 75 0 0] ());
  ([#"cw.ads" 74 0 0] ());
  ([#"cw.ads" 76 0 0] ());
  ([#"cw.ads" 78 0 0] ());
  ([#"cw.ads" 77 0 0] ());
  ([#"cw.ads" 79 0 0] ());
  ([#"cw.ads" 80 0 0] ());
  ([#"cw.ads" 82 0 0] ());
  ([#"cw.ads" 83 0 0] ());
  ([#"cw.ads" 86 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
  ([#"cw.ads" 85 0 0] ());
   assume {  ( ((Ada__text_io__line_length__2.line_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content) = (0 : int)) /\ ((Ada__text_io__page_length__2.page_length__2 Ada__text_io__standard_in.standard_in.Main.__private__content Ada__text_io__file_system.file_system.Main.__private__content Ada__text_io__standard_out.standard_out.Main.__private__content Ada__text_io__standard_err.standard_err.Main.__private__content Ada__text_io__current_in.current_in.Main.__private__content Ada__text_io__current_out.current_out.Main.__private__content Ada__text_io__current_err.current_err.Main.__private__content) = (0 : int)) ) };
  ();
  ([#"cw.adb" 3 0 0] ());
  ([#"cw.adb" 5 0 0] ());
  ([#"cw.adb" 15 0 0] ());
  ([#"cw.adb" 21 0 0] ());
  ([#"cw.adb" 27 0 0] ());
  ([#"cw.adb" 36 0 0] ());
  ([#"cw.adb" 45 0 0] ());
  ([#"cw.adb" 58 0 0] ());
  ([#"cw.adb" 65 0 0] ());
  ([#"cw.adb" 79 0 0] ());
  ([#"cw.adb" 93 0 0] ());
  ([#"cw.adb" 114 0 0] ());
  ([#"cw.adb" 120 0 0] ());
  ();
  ( [@GP_Sloc:cw.adb:143:1] ([#"cw.adb" 143 0 0] ()) ) )
end

(* Module for checking contracts and absence of run-time errors in subprogram "istrainmoving" defined at cw.ads:85, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__istrainmoving__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving__t as Cw__istrainmoving__t
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving__t___axiom as Cw__istrainmoving__t___axiom

 val cw__istrainmoving__result [@model_projected] [@name:IsTrainMoving] [@model_trace:4356@result]  : bool__ref 
 
 let def [#"cw.ads" 85 0 0][@GP_Subp:cw.ads:85] 
   (__void_param : unit)
  requires { [#"cw.ads" 85 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:85 *)
  ;
  [#"cw.ads" 85 0 0] assume { [#"cw.ads" 85 0 0] (Cw__train___axiom.dynamic_invariant Cw__istrainmoving__t.t True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:85 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:85 *)
  ;
  [#"cw.ads" 85 0 0] begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:85 *)
  ;
  [#"cw.ads" 85 0 0] try
   ( ();
   ( [@GP_Sloc:cw.ads:86:18] ([#"cw.ads" 86 0 0] ( [#"cw.ads" 86 0 0] (cw__istrainmoving__result.bool__content <- ( ((Cw__moving__rep.to_rep(Cw__istrainmoving__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (0 : int)) ));
   [#"cw.ads" 86 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end ;
  cw__istrainmoving__result.bool__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "emptycarriage" defined at cw.ads:52, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__emptycarriage__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Boolean as Boolean
 use        Cw__emptycarriage__t as Cw__emptycarriage__t
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__istrainmoving___axiom as Cw__istrainmoving___axiom
 use        Cw__emptycarriage__L_1__pos as Cw__emptycarriage__L_1__pos
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__moving as Cw__moving
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__trainrecord as Cw__trainrecord
 use        Cw__traincarriage as Cw__traincarriage
 use        Cw__emptycarriage__L_1 as Cw__emptycarriage__L_1
 use        Cw__emptycarriage__L_1__T1b as Cw__emptycarriage__L_1__T1b
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__emptycarriage__L_1__pos___axiom as Cw__emptycarriage__L_1__pos___axiom
 use        Cw__emptycarriage__L_1___axiom as Cw__emptycarriage__L_1___axiom
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__emptycarriage__t___axiom as Cw__emptycarriage__t___axiom
 use        Cw__istrainmoving___axiom as Cw__istrainmoving___axiom
 use        Cw__TcarriagerangeB___axiom as Cw__TcarriagerangeB___axiom
 use        Cw__emptycarriage__L_1__T1b___axiom as Cw__emptycarriage__L_1__T1b___axiom

 let def [#"cw.ads" 52 0 0][@GP_Subp:cw.ads:52] 
   (__void_param : unit)
  requires { [#"cw.ads" 52 0 0] true }
  ensures { [#"cw.ads" 52 0 0] ([#"cw.ads" 54 0 0] ( [@GP_Sloc:cw.ads:54:14] [@GP_Reason:VC_POSTCONDITION] [@comment:     Post => t.carriage.Top = CarriageRange'First and (for all J in t.carriage.carriages'First..t.carriage.carriages'Last => t.carriage.carriages(J) /= Loaded);              ^ cw.ads:54:14:VC_POSTCONDITION] [@model_vc_post] [@GP_Id:3] [@GP_Shape:pragargs__and] ( ( [@GP_Sloc:cw.ads:54:14] [@GP_Pretty_Ada:3755] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = (0 : int)) ) /\ (forall j [#"cw.ads" 54 0 0]  [@model_trace:3760] [@name:J]  : int.
   ( ( ((0 : int) <= j) /\ (j <= (10 : int)) ) -> ( [@GP_Sloc:cw.ads:54:126] [@GP_Pretty_Ada:3791] ((Cw__carriageslot__rep.to_rep (let temp___435 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
    (Array__Int__Cw__carriageslot.get temp___435 j)))
   ) <> (1 : int)) ) )) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:52 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:52 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:52 *)
  ;
   begin ensures {true} let _ = (let _ = (Boolean.andb(((Boolean.to_int((Cw__istrainmoving___axiom.istrainmoving({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content })))) = (Boolean.to_int((Boolean.of_int((0 : int))))))) (((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) > (0 : int)))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:52 *)
  ;
   assume {  ( ( [@GP_Pretty_Ada:3737] ( ((epsilon temp___result_434 : bool.
   ( (temp___result_434 = (Cw__istrainmoving.istrainmoving { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__istrainmoving.istrainmoving__function_guard temp___result_434 { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }) )) = True) <-> false ) ) /\ ( [@GP_Pretty_Ada:3745] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) > (0 : int)) ) ) };
   try
   ( ();
   ([#"cw.adb" 7 0 0] ());
   ();
   ( [@GP_Sloc:cw.adb:7:45] ([#"cw.adb" 7 0 0] (let temp___411 [@mlw:proxy_symbol] [@introduced] = (0 : int) in (
   (let temp___412 [@mlw:proxy_symbol] [@introduced] = (10 : int) in (
    ( [#"cw.adb" 7 0 0] (Cw__emptycarriage__L_1__pos.pos.int__content <- ( temp___411 ));
    () (* Translation of an Ada loop from cw.adb:7 *)
    ;
    (if ((Boolean.andb((temp___411 <= Cw__emptycarriage__L_1__pos.pos.int__content)) ((Cw__emptycarriage__L_1__pos.pos.int__content <= temp___412)))) then (
     [#"cw.adb" 7 0 0] try
      ( [#"cw.adb" 7 0 0] begin ensures {true} let _ = (let _ = Cw__emptycarriage__L_1__pos.pos.int__content in (
       ()))
       in () end ;
      (let temp___419 [@mlw:proxy_symbol] [@introduced] = [#"cw.adb" 7 0 0] (val _f : int
      ensures {[#"cw.adb" 7 0 0] (result = Cw__emptycarriage__L_1__pos.pos.int__content)} 
      in _f) in (
       ( [#"cw.adb" 7 0 0] begin ensures {true} let _ = (let _ = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
        ()))
        in () end ;
       (let temp___417 [@mlw:proxy_symbol] [@introduced] = [#"cw.adb" 7 0 0] (val _f : Cw__train.train
       ensures {[#"cw.adb" 7 0 0] (result = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content })} 
       in _f) in (
        [#"cw.adb" 7 0 0] let temp___424 [@mlw:proxy_symbol] [@introduced] = { int__content = (0 : int) } in 
         ( () (* First unroling of the loop statements appearing before the loop invariant of loop cw.adb:7 *)
         ;
         ();
         ( [@GP_Sloc:cw.adb:8:36] ([#"cw.adb" 8 0 0] (let temp___416 [@mlw:proxy_symbol] [@introduced] = (let temp___415 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
          ( [#"cw.adb" 8 0 0] begin ensures {true} let _ = (let _ = temp___415.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
           ()))
           in () end ;
          { ( temp___415 ) with Cw__train.__split_fields = { ( temp___415.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___414 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
           ( [#"cw.adb" 8 0 0] begin ensures {true} let _ = (let _ = temp___414.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
            ()))
            in () end ;
           { ( temp___414 ) with Cw__traincarriage.__split_fields = { ( temp___414.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__carriages = (let temp___413 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
            (Array__Int__Cw__carriageslot.set({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages) (Cw__emptycarriage__L_1__pos.pos.int__content) ((Cw__carriageslot__rep.of_rep((0 : int)))))))
            } } )))
           } } )))
          in (
          [#"cw.adb" 8 0 0] (Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___416.Cw__train.__split_fields ))))
         ) );
         () (* While loop translating the Ada loop from cw.adb:7 *)
         ;
         (let temp___inv_420 [@mlw:proxy_symbol] [@introduced] = ( (let j =  (val _f : int
         in _f) in (
          (if ((Boolean.andb(((0 : int) <= j)) ((j <= Cw__emptycarriage__L_1__pos.pos.int__content)))) then (
            begin ensures {true} let _ = (let _ = ((Cw__carriageslot__rep.to_rep((let temp___421 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
            (Array__Int__Cw__carriageslot.get(temp___421) ((  assert {  ([#"cw.adb" 9 0 0] ( [@GP_Sloc:cw.adb:9:104] [@comment:         pragma Loop_Invariant (for all J in t.carriage.carriages'First..(Pos) => t.carriage.carriages(J) /= Loaded);                                                                                                        ^ cw.adb:9:104:VC_INDEX_CHECK] [@vc:annotation] [@GP_Shape:L_1_while__pragargs__forall__cmp__ixdcomp] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:0] ( (Cw__carriagerange.first <= j) /\ (j <= Cw__carriagerange.last) ) )) };
            j )))))
           )) <> (1 : int)) in (
            ()))
            in () end ))))
         ;
          (val _f : bool
         ensures { ( (result = True) <-> (forall j   [@name:J] [@model_trace:2374]  : int.
          ( ( ((0 : int) <= j) /\ (j <= Cw__emptycarriage__L_1__pos.pos.int__content) ) -> ((Cw__carriageslot__rep.to_rep (let temp___422 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
           (Array__Int__Cw__carriageslot.get temp___422 j)))
          ) <> (1 : int)) )) )} 
         in _f) ) in (
           begin ensures {true} let _ = (let _ = () in (
           ()))
           in () end ))
         ;
          while True do
          invariant { 
           ([#"cw.adb" 9 0 0] ( [@GP_Reason:VC_LOOP_INVARIANT] [@comment:         pragma Loop_Invariant (for all J in t.carriage.carriages'First..(Pos) => t.carriage.carriages(J) /= Loaded);                                 ^ cw.adb:9:33:VC_LOOP_INVARIANT] [@vc:annotation] [@GP_Sloc:cw.adb:9:33] [@GP_Shape:L_1_while__pragargs__forall] [@GP_Id:1] (forall j [#"cw.adb" 9 0 0]  [@name:J] [@model_trace:2374]  : int.
            ( ( ((0 : int) <= j) /\ (j <= Cw__emptycarriage__L_1__pos.pos.int__content) ) -> ( [@GP_Pretty_Ada:2399] [@GP_Sloc:cw.adb:9:83] ((Cw__carriageslot__rep.to_rep (let temp___423 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
             (Array__Int__Cw__carriageslot.get temp___423 j)))
            ) <> (1 : int)) ) )) ))
           }
          ( () (* Assume implicit invariants from the loop cw.adb:7 *)
          ;
           assume {  (Boolean.andb(( ( ( ( true /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content } True True True True) )/\( ( ( ({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats = temp___417.Cw__train.__split_fields.Cw__train.rec__cw__train__stats) /\ ({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving = temp___417.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) ) /\ ( (forall temp___418   : int.
           (if (( (Cw__carriagerange.first <= temp___418) /\ (temp___418 <= Cw__carriagerange.last) )) then (
            (if (( (temp___412 < temp___418) \/ ( (temp___418 < temp___411) \/ (Cw__emptycarriage__L_1__pos.pos.int__content < temp___418) ) )) then (
             ((Array__Int__Cw__carriageslot.get { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages temp___418) = (Array__Int__Cw__carriageslot.get temp___417.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages temp___418))) else (
             true))) else true)) /\ ({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top = temp___417.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) ) ) /\ ({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor = temp___417.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor) ) ) /\ (if (( True \/ ((0 : int) <= (10 : int)) )) then (
           (Cw__emptycarriage__L_1__T1b.dynamic_property (0 : int) (10 : int) Cw__emptycarriage__L_1__pos.pos.int__content)) else true) )/\true )) (( ((0 : int) <= Cw__emptycarriage__L_1__pos.pos.int__content) /\ (Cw__emptycarriage__L_1__pos.pos.int__content <= (10 : int)) ))) };
          () (* Check for absence of RTE in the invariant of loop cw.adb:7 *)
          ;
           (temp___424.int__content <- ( Cw__emptycarriage__L_1__pos.pos.int__content ));
          () (* Loop statements appearing after the loop invariant of loop cw.adb:7 *)
          ;
          () (* Check for the exit condition and loop statements appearing before the loop invariant of loop cw.adb:7 *)
          ;
          (if ((Cw__emptycarriage__L_1__pos.pos.int__content = temp___412)) then (
            raise Cw__emptycarriage__L_1.L_1));
          ([#"cw.adb" 7 0 0] [#"cw.adb" 7 0 0] (Cw__emptycarriage__L_1__pos.pos.int__content <- ( (Cw__emptycarriage__L_1__pos.pos.int__content + (1 : int)) )));
          ();
          ( [@GP_Sloc:cw.adb:8:36] ([#"cw.adb" 8 0 0] (let temp___416 [@mlw:proxy_symbol] [@introduced] = (let temp___415 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
           ( [#"cw.adb" 8 0 0] begin ensures {true} let _ = (let _ = temp___415.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
            ()))
            in () end ;
           { ( temp___415 ) with Cw__train.__split_fields = { ( temp___415.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___414 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
            ( [#"cw.adb" 8 0 0] begin ensures {true} let _ = (let _ = temp___414.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
             ()))
             in () end ;
            { ( temp___414 ) with Cw__traincarriage.__split_fields = { ( temp___414.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__carriages = (let temp___413 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
             (Array__Int__Cw__carriageslot.set({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages) (Cw__emptycarriage__L_1__pos.pos.int__content) ((Cw__carriageslot__rep.of_rep((0 : int)))))))
             } } )))
            } } )))
           in (
           [#"cw.adb" 8 0 0] (Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___416.Cw__train.__split_fields ))))
          ) );
           begin ensures {true} let _ = (let _ =  begin ensures {true} let _ = (let _ = Cw__emptycarriage__L_1__pos.pos.int__content in (
           ()))
           in () end  in (
           ()))
           in () end ;
           check {  ([#"cw.adb" 10 0 0] ( [@GP_Reason:VC_LOOP_VARIANT] [@GP_Shape:L_1_while] [@comment:         pragma Loop_Variant (Increases => Pos);          ^ cw.adb:10:10:VC_LOOP_VARIANT] [@GP_Sloc:cw.adb:10:10] [@vc:annotation] [@GP_Id:2] (Cw__emptycarriage__L_1__pos.pos.int__content > temp___424.int__content) )) };
          (let temp___inv_420 [@mlw:proxy_symbol] [@introduced] = ( (let j =  (val _f : int
          in _f) in (
           (if ((Boolean.andb(((0 : int) <= j)) ((j <= Cw__emptycarriage__L_1__pos.pos.int__content)))) then (
             begin ensures {true} let _ = (let _ = ((Cw__carriageslot__rep.to_rep((let temp___421 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
             (Array__Int__Cw__carriageslot.get(temp___421) ((  assert {  ([#"cw.adb" 9 0 0] ( [@GP_Sloc:cw.adb:9:104] [@comment:         pragma Loop_Invariant (for all J in t.carriage.carriages'First..(Pos) => t.carriage.carriages(J) /= Loaded);                                                                                                        ^ cw.adb:9:104:VC_INDEX_CHECK] [@vc:annotation] [@GP_Shape:L_1_while__pragargs__forall__cmp__ixdcomp] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:0] ( (Cw__carriagerange.first <= j) /\ (j <= Cw__carriagerange.last) ) )) };
             j )))))
            )) <> (1 : int)) in (
             ()))
             in () end ))))
          ;
           (val _f : bool
          ensures { ( (result = True) <-> (forall j   [@name:J] [@model_trace:2374]  : int.
           ( ( ((0 : int) <= j) /\ (j <= Cw__emptycarriage__L_1__pos.pos.int__content) ) -> ((Cw__carriageslot__rep.to_rep (let temp___422 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
            (Array__Int__Cw__carriageslot.get temp___422 j)))
           ) <> (1 : int)) )) )} 
          in _f) ) in (
            begin ensures {true} let _ = (let _ = () in (
            ()))
            in () end ))
           )
         done )))
        )))
       )
     with
      Cw__emptycarriage__L_1.L_1 -> ()
     end)) )))
   ))
   ) );
   ( [@GP_Sloc:cw.adb:12:22] ([#"cw.adb" 12 0 0] (let temp___427 [@mlw:proxy_symbol] [@introduced] = (let temp___426 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
    ( [#"cw.adb" 12 0 0] begin ensures {true} let _ = (let _ = temp___426.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
     ()))
     in () end ;
    { ( temp___426 ) with Cw__train.__split_fields = { ( temp___426.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___425 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
     ( [#"cw.adb" 12 0 0] begin ensures {true} let _ = (let _ = temp___425.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
      ()))
      in () end ;
     { ( temp___425 ) with Cw__traincarriage.__split_fields = { ( temp___425.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__top = ( 0 : Cw__carriagerange.carriagerange ) } } )))
     } } )))
    in (
    [#"cw.adb" 12 0 0] (Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___427.Cw__train.__split_fields ))))
   ) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = (Boolean.andb(((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) = (0 : int))) (( (let j =  (val _f : int
  in _f) in (
   (if ((Boolean.andb(((0 : int) <= j)) ((j <= (10 : int))))) then (
     begin ensures {true} let _ = (let _ = ((Cw__carriageslot__rep.to_rep((let temp___430 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
     (Array__Int__Cw__carriageslot.get(temp___430) (j))))
    )) <> (1 : int)) in (
     ()))
     in () end ))))
  ;
   (val _f : bool
  ensures { ( (result = True) <-> (forall j   [@model_trace:3760] [@name:J]  : int.
   ( ( ((0 : int) <= j) /\ (j <= (10 : int)) ) -> ( [@GP_Pretty_Ada:3791] ((Cw__carriageslot__rep.to_rep (let temp___431 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__emptycarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
    (Array__Int__Cw__carriageslot.get temp___431 j)))
   ) <> (1 : int)) ) )) )} 
  in _f) ))) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "unloadcarriage" defined at cw.ads:55, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__unloadcarriage__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Boolean as Boolean
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__istrainmoving___axiom as Cw__istrainmoving___axiom
 use        Cw__unloadcarriage__t as Cw__unloadcarriage__t
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__traincarriage as Cw__traincarriage
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__unloadcarriage__t___axiom as Cw__unloadcarriage__t___axiom
 use        Cw__istrainmoving___axiom as Cw__istrainmoving___axiom

 let def [#"cw.ads" 55 0 0][@GP_Subp:cw.ads:55] 
   (__void_param : unit)
  requires { [#"cw.ads" 55 0 0] true }
  ensures { [#"cw.ads" 55 0 0] ([#"cw.ads" 57 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@GP_Sloc:cw.ads:57:14] [@comment:     Post => t.carriage.Top = t.carriage.Top'Old - 1 and t.carriage.carriages(t.carriage.Top'Old - 1) = Empty;              ^ cw.ads:57:14:VC_POSTCONDITION] [@model_vc_post] [@GP_Shape:pragargs__and] [@GP_Id:7] ( ( [@GP_Sloc:cw.ads:57:14] [@GP_Pretty_Ada:3836] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = ((Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )) - (1 : int))) ) /\ ( [@GP_Sloc:cw.ads:57:58] [@GP_Pretty_Ada:3862] ((Cw__carriageslot__rep.to_rep (let temp___453 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
   (Array__Int__Cw__carriageslot.get temp___453 ((Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )) - (1 : int)))))
  ) = (0 : int)) ) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:55 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:55 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:55 *)
  ;
   begin ensures {true} let _ = (let _ = (Boolean.andb(((Boolean.to_int((Cw__istrainmoving___axiom.istrainmoving({ Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content })))) = (Boolean.to_int((Boolean.of_int((0 : int))))))) (((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) > (0 : int)))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:55 *)
  ;
   assume {  ( ( [@GP_Pretty_Ada:3818] ( ((epsilon temp___result_452 : bool.
   ( (temp___result_452 = (Cw__istrainmoving.istrainmoving { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__istrainmoving.istrainmoving__function_guard temp___result_452 { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }) )) = True) <-> false ) ) /\ ( [@GP_Pretty_Ada:3826] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) > (0 : int)) ) ) };
   begin ensures {true} let _ = (let _ = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
   ()))
   in () end ;
  (let temp___old_448 [@mlw:proxy_symbol] [@introduced] =  (val _f : int
  ensures { (result = (Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top))} 
  in _f) in (
   (  begin ensures {true} let _ = (let _ = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
    ()))
    in () end ;
   (let temp___old_446 [@mlw:proxy_symbol] [@introduced] =  (val _f : int
   ensures { (result = (Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top))} 
   in _f) in (
    (  try
     ( ();
     ( [@GP_Sloc:cw.adb:17:48] ([#"cw.adb" 17 0 0] (let temp___440 [@mlw:proxy_symbol] [@introduced] = (let temp___439 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
      ( [#"cw.adb" 17 0 0] begin ensures {true} let _ = (let _ = temp___439.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ()))
       in () end ;
      { ( temp___439 ) with Cw__train.__split_fields = { ( temp___439.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___438 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ( [#"cw.adb" 17 0 0] begin ensures {true} let _ = (let _ = temp___438.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
        ()))
        in () end ;
       { ( temp___438 ) with Cw__traincarriage.__split_fields = { ( temp___438.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__carriages = (let temp___436 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
        (Array__Int__Cw__carriageslot.set({ Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages) ((let temp___437 [@mlw:proxy_symbol] [@introduced] = ((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) - (1 : int)) in (
         ( [#"cw.adb" 17 0 0] assert { [#"cw.adb" 17 0 0] ([#"cw.adb" 17 0 0] ( [@GP_Shape:t_assign__ixdcomp__sub] [@vc:annotation] [@GP_Sloc:cw.adb:17:43] [@GP_Reason:VC_INDEX_CHECK] [@comment:      t.carriage.carriages(t.carriage.Top - 1) := Empty;                                           ^ cw.adb:17:43:VC_INDEX_CHECK] [@GP_Id:4] ( (Cw__carriagerange.first <= temp___437) /\ (temp___437 <= Cw__carriagerange.last) ) )) };
         temp___437 )))
        ) ((Cw__carriageslot__rep.of_rep((0 : int)))))))
        } } )))
       } } )))
      in (
       (Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___440.Cw__train.__split_fields ))))
     ) );
     ( [@GP_Sloc:cw.adb:18:22] ([#"cw.adb" 18 0 0] (let temp___443 [@mlw:proxy_symbol] [@introduced] = (let temp___442 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
      ( [#"cw.adb" 18 0 0] begin ensures {true} let _ = (let _ = temp___442.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ()))
       in () end ;
      { ( temp___442 ) with Cw__train.__split_fields = { ( temp___442.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___441 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ( [#"cw.adb" 18 0 0] begin ensures {true} let _ = (let _ = temp___441.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
        ()))
        in () end ;
       { ( temp___441 ) with Cw__traincarriage.__split_fields = { ( temp___441.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__top = (Cw__carriagerange__rep.of_rep(([#"cw.adb" 18 0 0] ( [@vc:annotation] [@comment:      t.carriage.Top := t.carriage.Top - 1;                                        ^ cw.adb:18:40:VC_RANGE_CHECK] [@GP_Shape:t_assign__sub] [@GP_Reason:VC_RANGE_CHECK] [@GP_Sloc:cw.adb:18:40] [@GP_Id:5] (Cw__carriagerange.range_check_(((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) - (1 : int)))) )))) } } )))
       } } )))
      in (
       (Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___443.Cw__train.__split_fields ))))
     ) );
      raise Return__exc )
    with
     Return__exc -> ()
    end;
     begin ensures {true} let _ = (let _ = (Boolean.andb(((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) = (temp___old_446 - (1 : int)))) (((Cw__carriageslot__rep.to_rep((let temp___447 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
     (Array__Int__Cw__carriageslot.get(temp___447) ((let temp___449 [@mlw:proxy_symbol] [@introduced] = (temp___old_448 - (1 : int)) in (
      (  assert {  ([#"cw.ads" 57 0 0] ( [@GP_Sloc:cw.ads:57:98] [@comment:     Post => t.carriage.Top = t.carriage.Top'Old - 1 and t.carriage.carriages(t.carriage.Top'Old - 1) = Empty;                                                                                                  ^ cw.ads:57:98:VC_INDEX_CHECK] [@vc:annotation] [@GP_Shape:pragargs__and__cmp__ixdcomp__sub] [@GP_Reason:VC_INDEX_CHECK] [@GP_Id:6] ( (Cw__carriagerange.first <= temp___449) /\ (temp___449 <= Cw__carriagerange.last) ) )) };
      temp___449 )))
     ))))
    )) = (0 : int)))) in (
     ()))
     in () end  )))
    )))
   )
end

(* Module for checking contracts and absence of run-time errors in subprogram "loadcarriage" defined at cw.ads:58, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__loadcarriage__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Boolean as Boolean
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__istrainmoving as Cw__istrainmoving
 use        Cw__istrainmoving___axiom as Cw__istrainmoving___axiom
 use        Cw__loadcarriage__t as Cw__loadcarriage__t
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__carriagerange as Cw__carriagerange
 use        Cw__carriagerange__rep as Cw__carriagerange__rep
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__traincarriage as Cw__traincarriage
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadcarriage__t___axiom as Cw__loadcarriage__t___axiom
 use        Cw__istrainmoving___axiom as Cw__istrainmoving___axiom

 let def [#"cw.ads" 58 0 0][@GP_Subp:cw.ads:58] 
   (__void_param : unit)
  requires { [#"cw.ads" 58 0 0] true }
  ensures { [#"cw.ads" 58 0 0] ([#"cw.ads" 60 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@comment:     Post => t.carriage.Top = t.carriage.Top'Old + 1 and t.carriage.carriages(t.carriage.Top'Old) = Loaded;              ^ cw.ads:60:14:VC_POSTCONDITION] [@GP_Sloc:cw.ads:60:14] [@model_vc_post] [@GP_Shape:pragargs__and] [@GP_Id:9] ( ( [@GP_Pretty_Ada:3909] [@GP_Sloc:cw.ads:60:14] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) = ((Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )) + (1 : int))) ) /\ ( [@GP_Pretty_Ada:3933] [@GP_Sloc:cw.ads:60:58] ((Cw__carriageslot__rep.to_rep (let temp___469 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
   (Array__Int__Cw__carriageslot.get temp___469 (Cw__carriagerange__rep.to_rep (old { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top )))))
  ) = (1 : int)) ) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:58 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:58 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:58 *)
  ;
   begin ensures {true} let _ = (let _ = (Boolean.andb(((Boolean.to_int((Cw__istrainmoving___axiom.istrainmoving({ Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content })))) = (Boolean.to_int((Boolean.of_int((0 : int))))))) (((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) < (10 : int)))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:58 *)
  ;
   assume {  ( ( [@GP_Pretty_Ada:3889] ( ((epsilon temp___result_468 : bool.
   ( (temp___result_468 = (Cw__istrainmoving.istrainmoving { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__istrainmoving.istrainmoving__function_guard temp___result_468 { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }) )) = True) <-> false ) ) /\ ( [@GP_Pretty_Ada:3897] ((Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top) < (10 : int)) ) ) };
   begin ensures {true} let _ = (let _ = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
   ()))
   in () end ;
  (let temp___old_463 [@mlw:proxy_symbol] [@introduced] =  (val _f : int
  ensures { (result = (Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top))} 
  in _f) in (
   (  begin ensures {true} let _ = (let _ = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
    ()))
    in () end ;
   (let temp___old_465 [@mlw:proxy_symbol] [@introduced] =  (val _f : int
   ensures { (result = (Cw__carriagerange__rep.to_rep { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top))} 
   in _f) in (
    (  try
     ( ();
     ( [@GP_Sloc:cw.adb:23:44] ([#"cw.adb" 23 0 0] (let temp___457 [@mlw:proxy_symbol] [@introduced] = (let temp___456 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
      ( [#"cw.adb" 23 0 0] begin ensures {true} let _ = (let _ = temp___456.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ()))
       in () end ;
      { ( temp___456 ) with Cw__train.__split_fields = { ( temp___456.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___455 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ( [#"cw.adb" 23 0 0] begin ensures {true} let _ = (let _ = temp___455.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
        ()))
        in () end ;
       { ( temp___455 ) with Cw__traincarriage.__split_fields = { ( temp___455.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__carriages = (let temp___454 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
        (Array__Int__Cw__carriageslot.set({ Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages) ((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top))) ((Cw__carriageslot__rep.of_rep((1 : int)))))))
        } } )))
       } } )))
      in (
      [#"cw.adb" 23 0 0] (Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___457.Cw__train.__split_fields ))))
     ) );
     ( [@GP_Sloc:cw.adb:24:22] ([#"cw.adb" 24 0 0] (let temp___460 [@mlw:proxy_symbol] [@introduced] = (let temp___459 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content } in (
      ( [#"cw.adb" 24 0 0] begin ensures {true} let _ = (let _ = temp___459.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ()))
       in () end ;
      { ( temp___459 ) with Cw__train.__split_fields = { ( temp___459.Cw__train.__split_fields ) with Cw__train.rec__cw__train__carriage = (let temp___458 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage in (
       ( [#"cw.adb" 24 0 0] begin ensures {true} let _ = (let _ = temp___458.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top in (
        ()))
        in () end ;
       { ( temp___458 ) with Cw__traincarriage.__split_fields = { ( temp___458.Cw__traincarriage.__split_fields ) with Cw__traincarriage.rec__cw__traincarriage__top = (Cw__carriagerange__rep.of_rep(([#"cw.adb" 24 0 0] ( [@GP_Sloc:cw.adb:24:40] [@GP_Shape:t_assign__add] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@comment:      t.carriage.Top := t.carriage.Top + 1;                                        ^ cw.adb:24:40:VC_RANGE_CHECK] [@GP_Id:8] (Cw__carriagerange.range_check_(((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) + (1 : int)))) )))) } } )))
       } } )))
      in (
       (Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___460.Cw__train.__split_fields ))))
     ) );
      raise Return__exc )
    with
     Return__exc -> ()
    end;
     begin ensures {true} let _ = (let _ = (Boolean.andb(((Cw__carriagerange__rep.to_rep({ Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__top)) = (temp___old_463 + (1 : int)))) (((Cw__carriageslot__rep.to_rep((let temp___464 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadcarriage__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
     (Array__Int__Cw__carriageslot.get(temp___464) (temp___old_465))))
    )) = (1 : int)))) in (
     ()))
     in () end  )))
    )))
   )
end

(* Module for checking contracts and absence of run-time errors in subprogram "loadedrods" defined at cw.ads:83, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__loadedrods__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods__t as Cw__loadedrods__t
 use        Cw__loadedrods__count as Cw__loadedrods__count
 use        Cw__loadedrods__L_4__j as Cw__loadedrods__L_4__j
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Cw__rodcounter as Cw__rodcounter
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Cw__loadedrods__L_4 as Cw__loadedrods__L_4
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Cw__loadedrods__count___axiom as Cw__loadedrods__count___axiom
 use        Cw__loadedrods__L_4__j___axiom as Cw__loadedrods__L_4__j___axiom
 use        Cw__loadedrods__L_4___axiom as Cw__loadedrods__L_4___axiom
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods__t___axiom as Cw__loadedrods__t___axiom

 val cw__loadedrods__result [@name:LoadedRods] [@model_projected] [@model_trace:4337@result]  : int__ref 
 
 let def [#"cw.ads" 83 0 0][@GP_Subp:cw.ads:83] 
   (__void_param : unit)
  requires { [#"cw.ads" 83 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:83 *)
  ;
  [#"cw.ads" 83 0 0] assume { [#"cw.ads" 83 0 0] (Cw__train___axiom.dynamic_invariant Cw__loadedrods__t.t True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:83 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:83 *)
  ;
  [#"cw.ads" 83 0 0] begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:83 *)
  ;
  [#"cw.ads" 83 0 0] try
   ( ();
   ([#"cw.adb" 80 0 0] ( [#"cw.adb" 80 0 0] (Cw__loadedrods__count.count.int__content <- ( (0 : int) ));
   [#"cw.adb" 80 0 0] assume { [#"cw.adb" 80 0 0] (Cw__rodcounter___axiom.dynamic_invariant Cw__loadedrods__count.count.int__content True False True True) } ));
   ([#"cw.adb" 83 0 0] ());
   ();
   ( [@GP_Sloc:cw.adb:83:32] ([#"cw.adb" 83 0 0] (let temp___470 [@mlw:proxy_symbol] [@introduced] = (0 : int) in (
   (let temp___471 [@mlw:proxy_symbol] [@introduced] = (4 : int) in (
    ( () (* Translation of an Ada loop from cw.adb:83 *)
    ;
    [#"cw.adb" 83 0 0] try
     ( [#"cw.adb" 83 0 0] begin ensures {true} let _ = (let _ = Cw__loadedrods__count.count.int__content in (
      ()))
      in () end ;
     (let temp___473 [@mlw:proxy_symbol] [@introduced] = [#"cw.adb" 83 0 0] (val _f : int
     ensures {[#"cw.adb" 83 0 0] (result = Cw__loadedrods__count.count.int__content)} 
     in _f) in (
      ( () (* Unrolling of the loop statements of loop cw.adb:83 *)
      ;
      [#"cw.adb" 83 0 0] (Cw__loadedrods__L_4__j.j.int__content <- ( (0 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:84:10] ([#"cw.adb" 84 0 0] (if (( ([#"cw.adb" 84 0 0] [#"cw.adb" 84 0 0] (([@branch_id=2860] Main.spark__branch).bool__content <- ( ((Cw__rod__rep.to_rep((let temp___472 [@mlw:proxy_symbol] [@introduced] = Cw__loadedrods__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
       (Array__Int__Cw__rod.get(temp___472) (Cw__loadedrods__L_4__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2860] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:85:13] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:22] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:19] ([#"cw.adb" 85 0 0] [#"cw.adb" 85 0 0] (Cw__loadedrods__count.count.int__content <- ( ([#"cw.adb" 85 0 0] ( [@GP_Id:10] [@GP_Shape:L_4_while__if__count_assign__add] [@vc:annotation] [@GP_Sloc:cw.adb:85:28] [@GP_Reason:VC_RANGE_CHECK] [@comment:            count := count + RodCounter(1);                            ^ cw.adb:85:28:VC_RANGE_CHECK] (Cw__rodcounter.range_check_((Cw__loadedrods__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__loadedrods__L_4__j.j.int__content <- ( (1 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:84:10] ([#"cw.adb" 84 0 0] (if (( ([#"cw.adb" 84 0 0] [#"cw.adb" 84 0 0] (([@branch_id=2860] Main.spark__branch).bool__content <- ( ((Cw__rod__rep.to_rep((let temp___472 [@mlw:proxy_symbol] [@introduced] = Cw__loadedrods__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
       (Array__Int__Cw__rod.get(temp___472) (Cw__loadedrods__L_4__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2860] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:85:13] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:22] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:19] ([#"cw.adb" 85 0 0] [#"cw.adb" 85 0 0] (Cw__loadedrods__count.count.int__content <- ( ([#"cw.adb" 85 0 0] ( [@GP_Id:10] [@GP_Shape:L_4_while__if__count_assign__add] [@vc:annotation] [@GP_Sloc:cw.adb:85:28] [@GP_Reason:VC_RANGE_CHECK] [@comment:            count := count + RodCounter(1);                            ^ cw.adb:85:28:VC_RANGE_CHECK] (Cw__rodcounter.range_check_((Cw__loadedrods__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__loadedrods__L_4__j.j.int__content <- ( (2 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:84:10] ([#"cw.adb" 84 0 0] (if (( ([#"cw.adb" 84 0 0] [#"cw.adb" 84 0 0] (([@branch_id=2860] Main.spark__branch).bool__content <- ( ((Cw__rod__rep.to_rep((let temp___472 [@mlw:proxy_symbol] [@introduced] = Cw__loadedrods__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
       (Array__Int__Cw__rod.get(temp___472) (Cw__loadedrods__L_4__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2860] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:85:13] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:22] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:19] ([#"cw.adb" 85 0 0] [#"cw.adb" 85 0 0] (Cw__loadedrods__count.count.int__content <- ( ([#"cw.adb" 85 0 0] ( [@GP_Id:10] [@GP_Shape:L_4_while__if__count_assign__add] [@vc:annotation] [@GP_Sloc:cw.adb:85:28] [@GP_Reason:VC_RANGE_CHECK] [@comment:            count := count + RodCounter(1);                            ^ cw.adb:85:28:VC_RANGE_CHECK] (Cw__rodcounter.range_check_((Cw__loadedrods__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__loadedrods__L_4__j.j.int__content <- ( (3 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:84:10] ([#"cw.adb" 84 0 0] (if (( ([#"cw.adb" 84 0 0] [#"cw.adb" 84 0 0] (([@branch_id=2860] Main.spark__branch).bool__content <- ( ((Cw__rod__rep.to_rep((let temp___472 [@mlw:proxy_symbol] [@introduced] = Cw__loadedrods__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
       (Array__Int__Cw__rod.get(temp___472) (Cw__loadedrods__L_4__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2860] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:85:13] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:22] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:19] ([#"cw.adb" 85 0 0] [#"cw.adb" 85 0 0] (Cw__loadedrods__count.count.int__content <- ( ([#"cw.adb" 85 0 0] ( [@GP_Id:10] [@GP_Shape:L_4_while__if__count_assign__add] [@vc:annotation] [@GP_Sloc:cw.adb:85:28] [@GP_Reason:VC_RANGE_CHECK] [@comment:            count := count + RodCounter(1);                            ^ cw.adb:85:28:VC_RANGE_CHECK] (Cw__rodcounter.range_check_((Cw__loadedrods__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__loadedrods__L_4__j.j.int__content <- ( (4 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:84:10] ([#"cw.adb" 84 0 0] (if (( ([#"cw.adb" 84 0 0] [#"cw.adb" 84 0 0] (([@branch_id=2860] Main.spark__branch).bool__content <- ( ((Cw__rod__rep.to_rep((let temp___472 [@mlw:proxy_symbol] [@introduced] = Cw__loadedrods__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
       (Array__Int__Cw__rod.get(temp___472) (Cw__loadedrods__L_4__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2860] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:85:13] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:22] ([#"cw.adb" 85 0 0] ()) );
       ( [@GP_Sloc:cw.adb:85:19] ([#"cw.adb" 85 0 0] [#"cw.adb" 85 0 0] (Cw__loadedrods__count.count.int__content <- ( ([#"cw.adb" 85 0 0] ( [@GP_Id:10] [@GP_Shape:L_4_while__if__count_assign__add] [@vc:annotation] [@GP_Sloc:cw.adb:85:28] [@GP_Reason:VC_RANGE_CHECK] [@comment:            count := count + RodCounter(1);                            ^ cw.adb:85:28:VC_RANGE_CHECK] (Cw__rodcounter.range_check_((Cw__loadedrods__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) ) )))
      )
    with
     Cw__loadedrods__L_4.L_4 -> ()
    end )))
   ))
   ) );
   ( [@GP_Sloc:cw.adb:90:14] ([#"cw.adb" 90 0 0] ()) );
   ( [@GP_Sloc:cw.adb:90:7] ([#"cw.adb" 90 0 0] ( [#"cw.adb" 90 0 0] (cw__loadedrods__result.int__content <- ( Cw__loadedrods__count.count.int__content ));
   [#"cw.adb" 90 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end ;
  cw__loadedrods__result.int__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "loadrod" defined at cw.ads:61, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__loadrod__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadrod__t as Cw__loadrod__t
 use        Cw__loadrod__n as Cw__loadrod__n
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Cw__rodrange___axiom as Cw__rodrange___axiom
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__rodrange___axiom as Cw__rodrange___axiom
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadrod__t___axiom as Cw__loadrod__t___axiom
 use        Cw__loadrod__n___axiom as Cw__loadrod__n___axiom
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom

 let def [#"cw.ads" 61 0 0][@GP_Subp:cw.ads:61] 
   (__void_param : unit)
  requires { [#"cw.ads" 61 0 0] true }
  ensures { [#"cw.ads" 61 0 0] ([#"cw.ads" 63 0 0] ( [@GP_Id:11] [@GP_Reason:VC_POSTCONDITION] [@GP_Shape:pragargs__cmp] [@GP_Sloc:cw.ads:63:15] [@model_vc_post] [@comment:     Post =>  t.reactor(n) = Loaded;               ^ cw.ads:63:15:VC_POSTCONDITION] ( [@GP_Pretty_Ada:21826] [@GP_Sloc:cw.ads:63:15] ((Cw__rod__rep.to_rep (let temp___487 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___487 Cw__loadrod__n.n)))
  ) = (1 : int)) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:61 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
   assume {  (Cw__rodrange___axiom.dynamic_invariant Cw__loadrod__n.n True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:61 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:61 *)
  ;
   begin ensures {true} let _ = (let _ = (Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Cw__loadrod__n.n >= (1 : int))) ((Cw__loadrod__n.n <= (4 : int))))) (((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int))))) (((Cw__loadedrods___axiom.loadedrods({ Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content })) < (5 : int))))) (((Cw__rod__rep.to_rep((let temp___484 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get(temp___484) (Cw__loadrod__n.n))))
  )) = (0 : int)))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:61 *)
  ;
   assume {  ( ( ( ( ( [@GP_Pretty_Ada:3967] (Cw__loadrod__n.n >= (1 : int)) ) /\ ( [@GP_Pretty_Ada:3975] (Cw__loadrod__n.n <= (4 : int)) ) ) /\ ( [@GP_Pretty_Ada:3983] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) ) /\ ( [@GP_Pretty_Ada:3989] ((epsilon temp___result_485 : int.
   ( (temp___result_485 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_485 { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }) )) < (5 : int)) ) ) /\ ( [@GP_Pretty_Ada:3999] ((Cw__rod__rep.to_rep (let temp___486 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___486 Cw__loadrod__n.n)))
  ) = (0 : int)) ) ) };
   try
   ( ();
   ( [@GP_Sloc:cw.adb:30:7] ([#"cw.adb" 30 0 0] (if (( ([#"cw.adb" 30 0 0] [#"cw.adb" 30 0 0] (([@branch_id=2542] Main.spark__branch).bool__content <- ( ( ( (Cw__loadrod__n.n >= (1 : int)) && (Cw__loadrod__n.n < (5 : int)) ) && ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) ) )));
   ( [@branch_id=2542] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:cw.adb:32:23] ([#"cw.adb" 32 0 0] (let temp___478 [@mlw:proxy_symbol] [@introduced] = (let temp___477 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 32 0 0] begin ensures {true} let _ = (let _ = temp___477.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
      ()))
      in () end ;
     { ( temp___477 ) with Cw__train.__split_fields = { ( temp___477.Cw__train.__split_fields ) with Cw__train.rec__cw__train__reactor = (let temp___476 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
      (Array__Int__Cw__rod.set({ Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor) (Cw__loadrod__n.n) ((Cw__rod__rep.of_rep((1 : int)))))))
      } } )))
     in (
     [#"cw.adb" 32 0 0] (Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___478.Cw__train.__split_fields ))))
    ) ) )) else (
    ()))) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = ((Cw__rod__rep.to_rep((let temp___481 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__loadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get(temp___481) (Cw__loadrod__n.n))))
  )) = (1 : int)) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "unloadrod" defined at cw.ads:64, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__unloadrod__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom
 use        Cw__unloadrod__t as Cw__unloadrod__t
 use        Cw__unloadrod__n as Cw__unloadrod__n
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Cw__rodrange___axiom as Cw__rodrange___axiom
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__rodrange___axiom as Cw__rodrange___axiom
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__unloadrod__t___axiom as Cw__unloadrod__t___axiom
 use        Cw__unloadrod__n___axiom as Cw__unloadrod__n___axiom
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom

 let def [#"cw.ads" 64 0 0][@GP_Subp:cw.ads:64] 
   (__void_param : unit)
  requires { [#"cw.ads" 64 0 0] true }
  ensures { [#"cw.ads" 64 0 0] ([#"cw.ads" 66 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@GP_Id:12] [@GP_Shape:pragargs__cmp] [@model_vc_post] [@comment:     Post =>  t.reactor(n) = Empty;               ^ cw.ads:66:15:VC_POSTCONDITION] [@GP_Sloc:cw.ads:66:15] ( [@GP_Pretty_Ada:21896] [@GP_Sloc:cw.ads:66:15] ((Cw__rod__rep.to_rep (let temp___499 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___499 Cw__unloadrod__n.n)))
  ) = (0 : int)) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:64 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
   assume {  (Cw__rodrange___axiom.dynamic_invariant Cw__unloadrod__n.n True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:64 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:64 *)
  ;
   begin ensures {true} let _ = (let _ = (Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Cw__unloadrod__n.n >= (1 : int))) ((Cw__unloadrod__n.n <= (4 : int))))) (((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int))))) (((Cw__loadedrods___axiom.loadedrods({ Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content })) > (1 : int))))) (((Cw__rod__rep.to_rep((let temp___496 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get(temp___496) (Cw__unloadrod__n.n))))
  )) = (1 : int)))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:64 *)
  ;
   assume {  ( ( ( ( ( [@GP_Pretty_Ada:4043] (Cw__unloadrod__n.n >= (1 : int)) ) /\ ( [@GP_Pretty_Ada:4051] (Cw__unloadrod__n.n <= (4 : int)) ) ) /\ ( [@GP_Pretty_Ada:4059] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) ) /\ ( [@GP_Pretty_Ada:4065] ((epsilon temp___result_497 : int.
   ( (temp___result_497 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_497 { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }) )) > (1 : int)) ) ) /\ ( [@GP_Pretty_Ada:4077] ((Cw__rod__rep.to_rep (let temp___498 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get temp___498 Cw__unloadrod__n.n)))
  ) = (1 : int)) ) ) };
   try
   ( ();
   ( [@GP_Sloc:cw.adb:39:7] ([#"cw.adb" 39 0 0] (if (( ([#"cw.adb" 39 0 0] [#"cw.adb" 39 0 0] (([@branch_id=2593] Main.spark__branch).bool__content <- ( ( ( (Cw__unloadrod__n.n >= (1 : int)) && (Cw__unloadrod__n.n < (5 : int)) ) && ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) ) )));
   ( [@branch_id=2593] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:cw.adb:41:23] ([#"cw.adb" 41 0 0] (let temp___490 [@mlw:proxy_symbol] [@introduced] = (let temp___489 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 41 0 0] begin ensures {true} let _ = (let _ = temp___489.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
      ()))
      in () end ;
     { ( temp___489 ) with Cw__train.__split_fields = { ( temp___489.Cw__train.__split_fields ) with Cw__train.rec__cw__train__reactor = (let temp___488 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
      (Array__Int__Cw__rod.set({ Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor) (Cw__unloadrod__n.n) ((Cw__rod__rep.of_rep((0 : int)))))))
      } } )))
     in (
     [#"cw.adb" 41 0 0] (Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___490.Cw__train.__split_fields ))))
    ) ) )) else (
    ()))) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = ((Cw__rod__rep.to_rep((let temp___493 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__unloadrod__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
   (Array__Int__Cw__rod.get(temp___493) (Cw__unloadrod__n.n))))
  )) = (0 : int)) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "maintenancemodeon" defined at cw.ads:67, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__maintenancemodeon__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Boolean as Boolean
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__maintenancemodeon__t as Cw__maintenancemodeon__t
 use        Cw__maintenancemodeon__L_2__r as Cw__maintenancemodeon__L_2__r
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__rod as Cw__rod
 use        Cw__rod__rep as Cw__rod__rep
 use        Cw__rodrange as Cw__rodrange
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Cw__trainrecord as Cw__trainrecord
 use        Cw__traincarriage as Cw__traincarriage
 use        Cw__maintenancemodeon__L_2 as Cw__maintenancemodeon__L_2
 use        Cw__maintenancemodeon__L_2__T6b as Cw__maintenancemodeon__L_2__T6b
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Array__Int__Cw__rod as Array__Int__Cw__rod
 use        Cw__maintenancemodeon__L_2__r___axiom as Cw__maintenancemodeon__L_2__r___axiom
 use        Cw__maintenancemodeon__L_2___axiom as Cw__maintenancemodeon__L_2___axiom
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__rodrange___axiom as Cw__rodrange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__maintenancemodeon__t___axiom as Cw__maintenancemodeon__t___axiom
 use        Cw__TrodrangeB___axiom as Cw__TrodrangeB___axiom
 use        Cw__maintenancemodeon__L_2__T6b___axiom as Cw__maintenancemodeon__L_2__T6b___axiom

 let def [#"cw.ads" 67 0 0][@GP_Subp:cw.ads:67] 
   (__void_param : unit)
  requires { [#"cw.ads" 67 0 0] true }
  ensures { [#"cw.ads" 67 0 0] ([#"cw.ads" 69 0 0] ( [@GP_Sloc:cw.ads:69:14] [@GP_Reason:VC_POSTCONDITION] [@GP_Id:16] [@model_vc_post] [@comment:     Post => t.isMoving = Maintenance and (for all J in t.reactor'First..t.reactor'Last => t.reactor(J) /= Empty);              ^ cw.ads:69:14:VC_POSTCONDITION] [@GP_Shape:pragargs__and] ( ( [@GP_Sloc:cw.ads:69:14] [@GP_Pretty_Ada:4121] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (2 : int)) ) /\ (forall j [#"cw.ads" 69 0 0]  [@model_trace:4124] [@name:J]  : int.
   ( ( ((0 : int) <= j) /\ (j <= (4 : int)) ) -> ( [@GP_Pretty_Ada:4149] [@GP_Sloc:cw.ads:69:92] ((Cw__rod__rep.to_rep (let temp___521 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
    (Array__Int__Cw__rod.get temp___521 j)))
   ) <> (0 : int)) ) )) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:67 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:67 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:67 *)
  ;
   begin ensures {true} let _ = (let _ = ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:67 *)
  ;
   assume {  ( [@GP_Pretty_Ada:21923] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) };
   try
   ( ();
   ([#"cw.adb" 48 0 0] ());
   ();
   ( [@GP_Sloc:cw.adb:47:7] ([#"cw.adb" 47 0 0] (if (( ([#"cw.adb" 47 0 0] [#"cw.adb" 47 0 0] (([@branch_id=2636] Main.spark__branch).bool__content <- ( ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) )));
   ( [@branch_id=2636] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:cw.adb:48:35] ([#"cw.adb" 48 0 0] (let temp___500 [@mlw:proxy_symbol] [@introduced] = (0 : int) in (
    (let temp___501 [@mlw:proxy_symbol] [@introduced] = (4 : int) in (
     ( [#"cw.adb" 48 0 0] (Cw__maintenancemodeon__L_2__r.r.int__content <- ( temp___500 ));
     () (* Translation of an Ada loop from cw.adb:48 *)
     ;
     (if ((Boolean.andb((temp___500 <= Cw__maintenancemodeon__L_2__r.r.int__content)) ((Cw__maintenancemodeon__L_2__r.r.int__content <= temp___501)))) then (
      [#"cw.adb" 48 0 0] try
       ( [#"cw.adb" 48 0 0] begin ensures {true} let _ = (let _ = Cw__maintenancemodeon__L_2__r.r.int__content in (
        ()))
        in () end ;
       (let temp___507 [@mlw:proxy_symbol] [@introduced] = [#"cw.adb" 48 0 0] (val _f : int
       ensures {[#"cw.adb" 48 0 0] (result = Cw__maintenancemodeon__L_2__r.r.int__content)} 
       in _f) in (
        ( [#"cw.adb" 48 0 0] begin ensures {true} let _ = (let _ = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content } in (
         ()))
         in () end ;
        (let temp___505 [@mlw:proxy_symbol] [@introduced] = [#"cw.adb" 48 0 0] (val _f : Cw__train.train
        ensures {[#"cw.adb" 48 0 0] (result = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content })} 
        in _f) in (
         [#"cw.adb" 48 0 0] let temp___512 [@mlw:proxy_symbol] [@introduced] = { int__content = (0 : int) } in 
          ( () (* First unroling of the loop statements appearing before the loop invariant of loop cw.adb:48 *)
          ;
          ();
          ( [@GP_Sloc:cw.adb:49:26] ([#"cw.adb" 49 0 0] (let temp___504 [@mlw:proxy_symbol] [@introduced] = (let temp___503 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content } in (
           ( [#"cw.adb" 49 0 0] begin ensures {true} let _ = (let _ = temp___503.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
            ()))
            in () end ;
           { ( temp___503 ) with Cw__train.__split_fields = { ( temp___503.Cw__train.__split_fields ) with Cw__train.rec__cw__train__reactor = (let temp___502 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
            (Array__Int__Cw__rod.set({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor) (Cw__maintenancemodeon__L_2__r.r.int__content) ((Cw__rod__rep.of_rep((1 : int)))))))
            } } )))
           in (
           [#"cw.adb" 49 0 0] (Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___504.Cw__train.__split_fields ))))
          ) );
          () (* While loop translating the Ada loop from cw.adb:48 *)
          ;
          (let temp___inv_508 [@mlw:proxy_symbol] [@introduced] = ( (let j =  (val _f : int
          in _f) in (
           (if ((Boolean.andb(((0 : int) <= j)) ((j <= Cw__maintenancemodeon__L_2__r.r.int__content)))) then (
             begin ensures {true} let _ = (let _ = ((Cw__rod__rep.to_rep((let temp___509 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
             (Array__Int__Cw__rod.get(temp___509) ((  assert {  ([#"cw.adb" 50 0 0] ( [@GP_Id:13] [@vc:annotation] [@GP_Sloc:cw.adb:50:83] [@GP_Reason:VC_INDEX_CHECK] [@GP_Shape:if__L_2_while__pragargs__forall__cmp__ixdcomp] [@comment:            pragma Loop_Invariant (for all J in t.reactor'First..(r) => t.reactor(J) /= Empty);                                                                                   ^ cw.adb:50:83:VC_INDEX_CHECK] ( (Cw__rodrange.first <= j) /\ (j <= Cw__rodrange.last) ) )) };
             j )))))
            )) <> (0 : int)) in (
             ()))
             in () end ))))
          ;
           (val _f : bool
          ensures { ( (result = True) <-> (forall j   [@model_trace:2671] [@name:J]  : int.
           ( ( ((0 : int) <= j) /\ (j <= Cw__maintenancemodeon__L_2__r.r.int__content) ) -> ((Cw__rod__rep.to_rep (let temp___510 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
            (Array__Int__Cw__rod.get temp___510 j)))
           ) <> (0 : int)) )) )} 
          in _f) ) in (
            begin ensures {true} let _ = (let _ = () in (
            ()))
            in () end ))
          ;
           while True do
           invariant { 
            ([#"cw.adb" 50 0 0] ( [@GP_Sloc:cw.adb:50:36] [@GP_Id:14] [@GP_Reason:VC_LOOP_INVARIANT] [@vc:annotation] [@comment:            pragma Loop_Invariant (for all J in t.reactor'First..(r) => t.reactor(J) /= Empty);                                    ^ cw.adb:50:36:VC_LOOP_INVARIANT] [@GP_Shape:if__L_2_while__pragargs__forall] (forall j [#"cw.adb" 50 0 0]  [@model_trace:2671] [@name:J]  : int.
             ( ( ((0 : int) <= j) /\ (j <= Cw__maintenancemodeon__L_2__r.r.int__content) ) -> ( [@GP_Pretty_Ada:2692] [@GP_Sloc:cw.adb:50:73] ((Cw__rod__rep.to_rep (let temp___511 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
              (Array__Int__Cw__rod.get temp___511 j)))
             ) <> (0 : int)) ) )) ))
            }
           ( () (* Assume implicit invariants from the loop cw.adb:48 *)
           ;
            assume {  (Boolean.andb(( ( ( ( true /\ (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content } True True True True) )/\( ( ( ({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats = temp___505.Cw__train.__split_fields.Cw__train.rec__cw__train__stats) /\ ({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving = temp___505.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) ) /\ ({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage = temp___505.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage) ) /\ (forall temp___506   : int.
            (if (( (Cw__rodrange.first <= temp___506) /\ (temp___506 <= Cw__rodrange.last) )) then (
             (if (( (temp___501 < temp___506) \/ ( (temp___506 < temp___500) \/ (Cw__maintenancemodeon__L_2__r.r.int__content < temp___506) ) )) then (
              ((Array__Int__Cw__rod.get { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor temp___506) = (Array__Int__Cw__rod.get temp___505.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor temp___506))) else (
              true))) else true)) ) ) /\ (if (( True \/ ((0 : int) <= (4 : int)) )) then (
            (Cw__maintenancemodeon__L_2__T6b.dynamic_property (0 : int) (4 : int) Cw__maintenancemodeon__L_2__r.r.int__content)) else true) )/\true )) (( ((0 : int) <= Cw__maintenancemodeon__L_2__r.r.int__content) /\ (Cw__maintenancemodeon__L_2__r.r.int__content <= (4 : int)) ))) };
           () (* Check for absence of RTE in the invariant of loop cw.adb:48 *)
           ;
            (temp___512.int__content <- ( Cw__maintenancemodeon__L_2__r.r.int__content ));
           () (* Loop statements appearing after the loop invariant of loop cw.adb:48 *)
           ;
           () (* Check for the exit condition and loop statements appearing before the loop invariant of loop cw.adb:48 *)
           ;
           (if ((Cw__maintenancemodeon__L_2__r.r.int__content = temp___501)) then (
             raise Cw__maintenancemodeon__L_2.L_2));
           ([#"cw.adb" 48 0 0] [#"cw.adb" 48 0 0] (Cw__maintenancemodeon__L_2__r.r.int__content <- ( (Cw__maintenancemodeon__L_2__r.r.int__content + (1 : int)) )));
           ();
           ( [@GP_Sloc:cw.adb:49:26] ([#"cw.adb" 49 0 0] (let temp___504 [@mlw:proxy_symbol] [@introduced] = (let temp___503 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content } in (
            ( [#"cw.adb" 49 0 0] begin ensures {true} let _ = (let _ = temp___503.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
             ()))
             in () end ;
            { ( temp___503 ) with Cw__train.__split_fields = { ( temp___503.Cw__train.__split_fields ) with Cw__train.rec__cw__train__reactor = (let temp___502 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
             (Array__Int__Cw__rod.set({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor) (Cw__maintenancemodeon__L_2__r.r.int__content) ((Cw__rod__rep.of_rep((1 : int)))))))
             } } )))
            in (
            [#"cw.adb" 49 0 0] (Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___504.Cw__train.__split_fields ))))
           ) );
            begin ensures {true} let _ = (let _ =  begin ensures {true} let _ = (let _ = Cw__maintenancemodeon__L_2__r.r.int__content in (
            ()))
            in () end  in (
            ()))
            in () end ;
            check {  ([#"cw.adb" 51 0 0] ( [@GP_Reason:VC_LOOP_VARIANT] [@GP_Shape:if__L_2_while] [@GP_Id:15] [@vc:annotation] [@comment:            pragma Loop_Variant (Increases => r);             ^ cw.adb:51:13:VC_LOOP_VARIANT] [@GP_Sloc:cw.adb:51:13] (Cw__maintenancemodeon__L_2__r.r.int__content > temp___512.int__content) )) };
           (let temp___inv_508 [@mlw:proxy_symbol] [@introduced] = ( (let j =  (val _f : int
           in _f) in (
            (if ((Boolean.andb(((0 : int) <= j)) ((j <= Cw__maintenancemodeon__L_2__r.r.int__content)))) then (
              begin ensures {true} let _ = (let _ = ((Cw__rod__rep.to_rep((let temp___509 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
              (Array__Int__Cw__rod.get(temp___509) ((  assert {  ([#"cw.adb" 50 0 0] ( [@GP_Id:13] [@vc:annotation] [@GP_Sloc:cw.adb:50:83] [@GP_Reason:VC_INDEX_CHECK] [@GP_Shape:if__L_2_while__pragargs__forall__cmp__ixdcomp] [@comment:            pragma Loop_Invariant (for all J in t.reactor'First..(r) => t.reactor(J) /= Empty);                                                                                   ^ cw.adb:50:83:VC_INDEX_CHECK] ( (Cw__rodrange.first <= j) /\ (j <= Cw__rodrange.last) ) )) };
              j )))))
             )) <> (0 : int)) in (
              ()))
              in () end ))))
           ;
            (val _f : bool
           ensures { ( (result = True) <-> (forall j   [@model_trace:2671] [@name:J]  : int.
            ( ( ((0 : int) <= j) /\ (j <= Cw__maintenancemodeon__L_2__r.r.int__content) ) -> ((Cw__rod__rep.to_rep (let temp___510 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
             (Array__Int__Cw__rod.get temp___510 j)))
            ) <> (0 : int)) )) )} 
           in _f) ) in (
             begin ensures {true} let _ = (let _ = () in (
             ()))
             in () end ))
            )
          done )))
         )))
        )
      with
       Cw__maintenancemodeon__L_2.L_2 -> ()
      end)) )))
    ))
    ) );
    ( [@GP_Sloc:cw.adb:53:21] ([#"cw.adb" 53 0 0] (let temp___514 [@mlw:proxy_symbol] [@introduced] = (let temp___513 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 53 0 0] begin ensures {true} let _ = (let _ = temp___513.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving in (
      ()))
      in () end ;
     { ( temp___513 ) with Cw__train.__split_fields = { ( temp___513.Cw__train.__split_fields ) with Cw__train.rec__cw__train__ismoving = (Cw__moving__rep.of_rep((2 : int))) } } )))
     in (
     [#"cw.adb" 53 0 0] (Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___514.Cw__train.__split_fields ))))
    ) ) )) else (
    ()))) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = (Boolean.andb(((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (2 : int))) (( (let j =  (val _f : int
  in _f) in (
   (if ((Boolean.andb(((0 : int) <= j)) ((j <= (4 : int))))) then (
     begin ensures {true} let _ = (let _ = ((Cw__rod__rep.to_rep((let temp___517 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
     (Array__Int__Cw__rod.get(temp___517) (j))))
    )) <> (0 : int)) in (
     ()))
     in () end ))))
  ;
   (val _f : bool
  ensures { ( (result = True) <-> (forall j   [@model_trace:4124] [@name:J]  : int.
   ( ( ((0 : int) <= j) /\ (j <= (4 : int)) ) -> ( [@GP_Pretty_Ada:4149] ((Cw__rod__rep.to_rep (let temp___518 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeon__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__reactor in (
    (Array__Int__Cw__rod.get temp___518 j)))
   ) <> (0 : int)) ) )) )} 
  in _f) ))) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "maintenancemodeoff" defined at cw.ads:70, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__maintenancemodeoff__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__maintenancemodeoff__t as Cw__maintenancemodeoff__t
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__maintenancemodeoff__t___axiom as Cw__maintenancemodeoff__t___axiom

 let def [#"cw.ads" 70 0 0][@GP_Subp:cw.ads:70] 
   (__void_param : unit)
  requires { [#"cw.ads" 70 0 0] true }
  ensures { [#"cw.ads" 70 0 0] ([#"cw.ads" 72 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@GP_Id:17] [@GP_Shape:pragargs__cmp] [@GP_Sloc:cw.ads:72:14] [@model_vc_post] [@comment:     Post => t.isMoving = False;              ^ cw.ads:72:14:VC_POSTCONDITION] ( [@GP_Sloc:cw.ads:72:14] [@GP_Pretty_Ada:21993] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:70 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:70 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:70 *)
  ;
   begin ensures {true} let _ = (let _ = ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (2 : int)) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:70 *)
  ;
   assume {  ( [@GP_Pretty_Ada:21981] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (2 : int)) ) };
   try
   ( ();
   ( [@GP_Sloc:cw.adb:60:7] ([#"cw.adb" 60 0 0] (if (( ([#"cw.adb" 60 0 0] [#"cw.adb" 60 0 0] (([@branch_id=2727] Main.spark__branch).bool__content <- ( ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (2 : int)) )));
   ( [@branch_id=2727] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:cw.adb:61:21] ([#"cw.adb" 61 0 0] (let temp___523 [@mlw:proxy_symbol] [@introduced] = (let temp___522 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 61 0 0] begin ensures {true} let _ = (let _ = temp___522.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving in (
      ()))
      in () end ;
     { ( temp___522 ) with Cw__train.__split_fields = { ( temp___522.Cw__train.__split_fields ) with Cw__train.rec__cw__train__ismoving = (Cw__moving__rep.of_rep((1 : int))) } } )))
     in (
     [#"cw.adb" 61 0 0] (Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___523.Cw__train.__split_fields ))))
    ) ) )) else (
    ()))) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__maintenancemodeoff__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "updatestats" defined at cw.ads:73, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__updatestats__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Boolean as Boolean
 use        Standard__integer as Standard__integer
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom
 use        Cw__updatestats__t as Cw__updatestats__t
 use        Cw__connectedcarriages___axiom as Cw__connectedcarriages___axiom
 use        Cw__updatestats__carrcount as Cw__updatestats__carrcount
 use        Cw__updatestats__rodcount as Cw__updatestats__rodcount
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__energy as Cw__energy
 use        Cw__energy__rep as Cw__energy__rep
 use        Cw__heat as Cw__heat
 use        Cw__heat__rep as Cw__heat__rep
 use        Cw__speed as Cw__speed
 use        Cw__speed__rep as Cw__speed__rep
 use        Cw__carriagecounter___axiom as Cw__carriagecounter___axiom
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Cw__increaserrange as Cw__increaserrange
 use        Cw__increaserrange__rep as Cw__increaserrange__rep
 use        Cw__depleterrange as Cw__depleterrange
 use        Cw__depleterrange__rep as Cw__depleterrange__rep
 use        Cw__trainrecord as Cw__trainrecord
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Cw__updatestats__carrcount___axiom as Cw__updatestats__carrcount___axiom
 use        Cw__updatestats__rodcount___axiom as Cw__updatestats__rodcount___axiom
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__carriagecounter___axiom as Cw__carriagecounter___axiom
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__updatestats__t___axiom as Cw__updatestats__t___axiom
 use        Cw__connectedcarriages___axiom as Cw__connectedcarriages___axiom
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom

 let def [#"cw.ads" 73 0 0][@GP_Subp:cw.ads:73] 
   (__void_param : unit)
  requires { [#"cw.ads" 73 0 0] true }
  ensures { [#"cw.ads" 73 0 0] ([#"cw.ads" 75 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@GP_Id:44] [@GP_Sloc:cw.ads:75:14] [@model_vc_post] [@GP_Shape:pragargs__and] [@comment:     Post => t.stats.temperature > 0.0 and t.stats.tempIncreaser > 0 and t.stats.waterDepletion > 0;              ^ cw.ads:75:14:VC_POSTCONDITION] ( ( ( [@GP_Pretty_Ada:4230] [@GP_Sloc:cw.ads:75:14] (Float32.gt (Cw__heat__rep.to_rep { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__temperature) (0.0E-1:Float32.t)) ) /\ ( [@GP_Pretty_Ada:4238] [@GP_Sloc:cw.ads:75:44] ((Cw__increaserrange__rep.to_rep { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__tempincreaser) > (0 : int)) ) ) /\ ( [@GP_Pretty_Ada:4246] [@GP_Sloc:cw.ads:75:74] ((Cw__depleterrange__rep.to_rep { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__waterdepletion) > (0 : int)) ) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:73 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:73 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:73 *)
  ;
   begin ensures {true} let _ = (let _ = (Boolean.andb((Boolean.andb(((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int))) (((Cw__loadedrods___axiom.loadedrods({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content })) > (0 : int))))) ((Boolean.of_int((1 : int))))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:73 *)
  ;
   assume {  ( ( ( [@GP_Pretty_Ada:4210] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) /\ ( [@GP_Pretty_Ada:4216] ((epsilon temp___result_553 : int.
   ( (temp___result_553 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_553 { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }) )) > (0 : int)) ) ) /\ ( [@GP_Pretty_Ada:4220] true ) ) };
   try
   ( ();
   ([#"cw.adb" 94 0 0] ());
   ([#"cw.adb" 94 0 0] ( [#"cw.adb" 94 0 0] (Cw__updatestats__carrcount.carrcount.int__content <- ( (Cw__connectedcarriages___axiom.connectedcarriages({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content })) ));
   [#"cw.adb" 94 0 0] assume { [#"cw.adb" 94 0 0] (Cw__carriagecounter___axiom.dynamic_invariant Cw__updatestats__carrcount.carrcount.int__content True False True True) } ));
   ([#"cw.adb" 95 0 0] ());
   ([#"cw.adb" 95 0 0] ( [#"cw.adb" 95 0 0] (Cw__updatestats__rodcount.rodcount.int__content <- ( (Cw__loadedrods___axiom.loadedrods({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content })) ));
   [#"cw.adb" 95 0 0] assume { [#"cw.adb" 95 0 0] (Cw__rodcounter___axiom.dynamic_invariant Cw__updatestats__rodcount.rodcount.int__content True False True True) } ));
   ();
   ( [@GP_Sloc:cw.adb:97:7] ([#"cw.adb" 97 0 0] (if (( ([#"cw.adb" 97 0 0] [#"cw.adb" 97 0 0] (([@branch_id=2926] Main.spark__branch).bool__content <- ( ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) )));
   ( [@branch_id=2926] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:cw.adb:99:79] ([#"cw.adb" 99 0 0] ()) );
    ( [@GP_Sloc:cw.adb:99:29] ([#"cw.adb" 99 0 0] (let temp___530 [@mlw:proxy_symbol] [@introduced] = (let temp___529 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 99 0 0] begin ensures {true} let _ = (let _ = temp___529.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___529 ) with Cw__train.__split_fields = { ( temp___529.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___528 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 99 0 0] begin ensures {true} let _ = (let _ = temp___528.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currenergy in (
       ()))
       in () end ;
      { ( temp___528 ) with Cw__trainrecord.__split_fields = { ( temp___528.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__currenergy = (Cw__energy__rep.of_rep(([#"cw.adb" 99 0 0] ( [@vc:annotation] [@GP_Shape:if__t_assign__typeconv__mult] [@GP_Sloc:cw.adb:99:89] [@GP_Reason:VC_RANGE_CHECK] [@GP_Id:21] [@comment:         t.stats.currEnergy := Energy(((Float(t.reactor'Length) +1.0) - Float(rodCount))*20.0);                                                                                         ^ cw.adb:99:89:VC_RANGE_CHECK] (Cw__energy.range_check_((Float32.mul_rne((Float32.sub_rne((6.0:Float32.t)) ((Float32.of_int_rne(Cw__updatestats__rodcount.rodcount.int__content))))) ((20.0:Float32.t))))) )))) } } )))
      } } )))
     in (
      (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___530.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:101:67] ([#"cw.adb" 101 0 0] ()) );
    ( [@GP_Sloc:cw.adb:101:29] ([#"cw.adb" 101 0 0] (let temp___533 [@mlw:proxy_symbol] [@introduced] = (let temp___532 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 101 0 0] begin ensures {true} let _ = (let _ = temp___532.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___532 ) with Cw__train.__split_fields = { ( temp___532.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___531 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 101 0 0] begin ensures {true} let _ = (let _ = temp___531.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currenergy in (
       ()))
       in () end ;
      { ( temp___531 ) with Cw__trainrecord.__split_fields = { ( temp___531.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__currenergy = (Cw__energy__rep.of_rep(([#"cw.adb" 101 0 0] ( [@GP_Shape:if__t_assign__sub] [@GP_Sloc:cw.adb:101:51] [@vc:annotation] [@comment:         t.stats.currEnergy := t.stats.currEnergy - (Energy(Float(rodCount) * 0.1) * t.stats.currEnergy);                                                   ^ cw.adb:101:51:VC_RANGE_CHECK] [@GP_Reason:VC_RANGE_CHECK] [@GP_Id:27] (Cw__energy.range_check_((Float32.sub_rne((Cw__energy__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currenergy))) ((Float32.mul_rne((Float32.mul_rne((Float32.of_int_rne(Cw__updatestats__rodcount.rodcount.int__content))) ((0.100000001490116119384765625:Float32.t)))) ((Cw__energy__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currenergy)))))))) )))) } } )))
      } } )))
     in (
      (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___533.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:103:31] ([#"cw.adb" 103 0 0] (let temp___536 [@mlw:proxy_symbol] [@introduced] = (let temp___535 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 103 0 0] begin ensures {true} let _ = (let _ = temp___535.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___535 ) with Cw__train.__split_fields = { ( temp___535.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___534 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 103 0 0] begin ensures {true} let _ = (let _ = temp___534.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currmaxspeed in (
       ()))
       in () end ;
      { ( temp___534 ) with Cw__trainrecord.__split_fields = { ( temp___534.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__currmaxspeed = (Cw__speed__rep.of_rep((Float32.mul_rne((5.0:Float32.t)) ((Cw__energy__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currenergy)))))) } } )))
      } } )))
     in (
     [#"cw.adb" 103 0 0] (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___536.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:105:69] ([#"cw.adb" 105 0 0] ()) );
    ( [@GP_Sloc:cw.adb:105:31] ([#"cw.adb" 105 0 0] (let temp___539 [@mlw:proxy_symbol] [@introduced] = (let temp___538 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 105 0 0] begin ensures {true} let _ = (let _ = temp___538.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___538 ) with Cw__train.__split_fields = { ( temp___538.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___537 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 105 0 0] begin ensures {true} let _ = (let _ = temp___537.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currmaxspeed in (
       ()))
       in () end ;
      { ( temp___537 ) with Cw__trainrecord.__split_fields = { ( temp___537.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__currmaxspeed = (Cw__speed__rep.of_rep(([#"cw.adb" 105 0 0] ( [@GP_Sloc:cw.adb:105:55] [@GP_Shape:if__t_assign__sub] [@vc:annotation] [@GP_Id:35] [@GP_Reason:VC_RANGE_CHECK] [@comment:         t.stats.currMaxSpeed := t.stats.currMaxSpeed - Speed(Float(carrCount) * 0.04) *t.stats.currMaxSpeed;                                                       ^ cw.adb:105:55:VC_RANGE_CHECK] (Cw__speed.range_check_((Float32.sub_rne((Cw__speed__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currmaxspeed))) ((Float32.mul_rne((Float32.mul_rne((Float32.of_int_rne(Cw__updatestats__carrcount.carrcount.int__content))) ((0.0399999991059303283691406250:Float32.t)))) ((Cw__speed__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currmaxspeed)))))))) )))) } } )))
      } } )))
     in (
      (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___539.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:107:78] ([#"cw.adb" 107 0 0] ()) );
    ( [@GP_Sloc:cw.adb:107:30] ([#"cw.adb" 107 0 0] (let temp___542 [@mlw:proxy_symbol] [@introduced] = (let temp___541 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 107 0 0] begin ensures {true} let _ = (let _ = temp___541.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___541 ) with Cw__train.__split_fields = { ( temp___541.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___540 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 107 0 0] begin ensures {true} let _ = (let _ = temp___540.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__temperature in (
       ()))
       in () end ;
      { ( temp___540 ) with Cw__trainrecord.__split_fields = { ( temp___540.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__temperature = (Cw__heat__rep.of_rep((Float32.mul_rne((Float32.sub_rne((6.0:Float32.t)) ((Float32.of_int_rne(Cw__updatestats__rodcount.rodcount.int__content))))) ((10.0:Float32.t))))) } } )))
      } } )))
     in (
     [#"cw.adb" 107 0 0] (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___542.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:108:83] ([#"cw.adb" 108 0 0] ()) );
    ( [@GP_Sloc:cw.adb:108:32] ([#"cw.adb" 108 0 0] (let temp___545 [@mlw:proxy_symbol] [@introduced] = (let temp___544 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 108 0 0] begin ensures {true} let _ = (let _ = temp___544.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___544 ) with Cw__train.__split_fields = { ( temp___544.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___543 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 108 0 0] begin ensures {true} let _ = (let _ = temp___543.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__tempincreaser in (
       ()))
       in () end ;
      { ( temp___543 ) with Cw__trainrecord.__split_fields = { ( temp___543.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__tempincreaser = (Cw__increaserrange__rep.of_rep(([#"cw.adb" 108 0 0] ( [@GP_Id:41] [@vc:annotation] [@GP_Shape:if__t_assign__typeconv__mult] [@GP_Reason:VC_RANGE_CHECK] [@comment:         t.stats.tempIncreaser := IncreaserRange(((t.reactor'Length +1) - Integer(rodCount)) * 20);                                                                                              ^ cw.adb:108:94:VC_RANGE_CHECK] [@GP_Sloc:cw.adb:108:94] (Cw__increaserrange.range_check_(([#"cw.adb" 108 0 0] ( [@comment:         t.stats.tempIncreaser := IncreaserRange(((t.reactor'Length +1) - Integer(rodCount)) * 20);                                                                                              ^ cw.adb:108:94:VC_OVERFLOW_CHECK] [@GP_Id:40] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Shape:if__t_assign__typeconv__mult] [@GP_Sloc:cw.adb:108:94] (Standard__integer.range_check_((((6 : int) - Cw__updatestats__rodcount.rodcount.int__content) * (20 : int)))) )))) )))) } } )))
      } } )))
     in (
      (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___545.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:109:84] ([#"cw.adb" 109 0 0] ()) );
    ( [@GP_Sloc:cw.adb:109:33] ([#"cw.adb" 109 0 0] (let temp___548 [@mlw:proxy_symbol] [@introduced] = (let temp___547 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 109 0 0] begin ensures {true} let _ = (let _ = temp___547.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___547 ) with Cw__train.__split_fields = { ( temp___547.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___546 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 109 0 0] begin ensures {true} let _ = (let _ = temp___546.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__waterdepletion in (
       ()))
       in () end ;
      { ( temp___546 ) with Cw__trainrecord.__split_fields = { ( temp___546.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__waterdepletion = (Cw__depleterrange__rep.of_rep(([#"cw.adb" 109 0 0] ( [@GP_Id:43] [@GP_Sloc:cw.adb:109:94] [@vc:annotation] [@GP_Shape:if__t_assign__typeconv__mult] [@GP_Reason:VC_RANGE_CHECK] [@comment:         t.stats.waterDepletion :=  DepleterRange(((t.reactor'Length +1) - Integer(rodCount))*3);                                                                                              ^ cw.adb:109:94:VC_RANGE_CHECK] (Cw__depleterrange.range_check_(([#"cw.adb" 109 0 0] ( [@GP_Id:42] [@GP_Sloc:cw.adb:109:94] [@vc:annotation] [@GP_Reason:VC_OVERFLOW_CHECK] [@GP_Shape:if__t_assign__typeconv__mult] [@comment:         t.stats.waterDepletion :=  DepleterRange(((t.reactor'Length +1) - Integer(rodCount))*3);                                                                                              ^ cw.adb:109:94:VC_OVERFLOW_CHECK] (Standard__integer.range_check_((((6 : int) - Cw__updatestats__rodcount.rodcount.int__content) * (3 : int)))) )))) )))) } } )))
      } } )))
     in (
      (Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___548.Cw__train.__split_fields ))))
    ) ) )) else (
    ()))) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = (Boolean.andb((Boolean.andb((Float32.gt((Cw__heat__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__temperature))) ((0.0E-1:Float32.t)))) (((Cw__increaserrange__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__tempincreaser)) > (0 : int))))) (((Cw__depleterrange__rep.to_rep({ Cw__train.__split_fields = Cw__updatestats__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__waterdepletion)) > (0 : int)))) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "refillwater" defined at cw.ads:76, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__refillwater__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Float32 as Float32
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__refillwater__t as Cw__refillwater__t
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__water as Cw__water
 use        Cw__water__rep as Cw__water__rep
 use        Cw__trainrecord as Cw__trainrecord
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__refillwater__t___axiom as Cw__refillwater__t___axiom

 let def [#"cw.ads" 76 0 0][@GP_Subp:cw.ads:76] 
   (__void_param : unit)
  requires { [#"cw.ads" 76 0 0] true }
  ensures { [#"cw.ads" 76 0 0] ([#"cw.ads" 78 0 0] ( [@GP_Reason:VC_POSTCONDITION] [@GP_Id:45] [@GP_Shape:pragargs__cmp] [@model_vc_post] [@GP_Sloc:cw.ads:78:14] [@comment:     Post => t.stats.waterTank = Water'Last;              ^ cw.ads:78:14:VC_POSTCONDITION] ( [@GP_Pretty_Ada:22102] [@GP_Sloc:cw.ads:78:14] (Float32.eq (Cw__water__rep.to_rep { Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank) (100.0:Float32.t)) ) )) }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:76 *)
  ;
   assume {  (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:76 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:76 *)
  ;
   begin ensures {true} let _ = (let _ = ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:76 *)
  ;
   assume {  ( [@GP_Pretty_Ada:22087] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) };
   try
   ( ();
   ( [@GP_Sloc:cw.adb:116:25] ([#"cw.adb" 116 0 0] (let temp___556 [@mlw:proxy_symbol] [@introduced] = (let temp___555 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content } in (
    ( [#"cw.adb" 116 0 0] begin ensures {true} let _ = (let _ = temp___555.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
     ()))
     in () end ;
    { ( temp___555 ) with Cw__train.__split_fields = { ( temp___555.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___554 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
     ( [#"cw.adb" 116 0 0] begin ensures {true} let _ = (let _ = temp___554.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank in (
      ()))
      in () end ;
     { ( temp___554 ) with Cw__trainrecord.__split_fields = { ( temp___554.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__watertank = (Cw__water__rep.of_rep((100.0:Float32.t))) } } )))
     } } )))
    in (
    [#"cw.adb" 116 0 0] (Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___556.Cw__train.__split_fields ))))
   ) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = (Float32.eq((Cw__water__rep.to_rep({ Cw__train.__split_fields = Cw__refillwater__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank))) ((100.0:Float32.t))) in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "movetrain" defined at cw.ads:79, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__movetrain__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        "_gnatprove_standard".Float32 as Float32
 use        "_gnatprove_standard".Boolean as Boolean
 use        Standard__float as Standard__float
 use        Standard__float___axiom as Standard__float___axiom
 use        Standard__string as Standard__string
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__loadedrods as Cw__loadedrods
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom
 use        Cw__updatestats___axiom as Cw__updatestats___axiom
 use        Cw__movetrain__t as Cw__movetrain__t
 use        Cw__movetrain__distancemade as Cw__movetrain__distancemade
 use        Cw__movetrain__hoursonheat as Cw__movetrain__hoursonheat
 use        Ada__text_io__put__4___axiom as Ada__text_io__put__4___axiom
 use        Ada__float_text_io__put__2___axiom as Ada__float_text_io__put__2___axiom
 use        Cw__moving as Cw__moving
 use        Cw__moving__rep as Cw__moving__rep
 use        Cw__heat as Cw__heat
 use        Cw__heat__rep as Cw__heat__rep
 use        Cw__TwaterB as Cw__TwaterB
 use        Cw__water as Cw__water
 use        Cw__water__rep as Cw__water__rep
 use        Cw__speed as Cw__speed
 use        Cw__speed__rep as Cw__speed__rep
 use        Cw__increaserrange as Cw__increaserrange
 use        Cw__increaserrange__rep as Cw__increaserrange__rep
 use        Cw__depleterrange as Cw__depleterrange
 use        Cw__depleterrange__rep as Cw__depleterrange__rep
 use        Cw__trainrecord as Cw__trainrecord
 use        Temp___String_Literal_567 as Temp___String_Literal_567
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Array__Int__Standard__character as Array__Int__Standard__character
 use        Standard__positive___axiom as Standard__positive___axiom
 use        Standard__float___axiom as Standard__float___axiom
 use        Standard__character___axiom as Standard__character___axiom
 use        Standard__string___axiom as Standard__string___axiom
 use        Standard__integer___axiom as Standard__integer___axiom
 use        Cw__movetrain__distancemade___axiom as Cw__movetrain__distancemade___axiom
 use        Cw__movetrain__hoursonheat___axiom as Cw__movetrain__hoursonheat___axiom
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__rodcounter___axiom as Cw__rodcounter___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__updatestats___axiom as Cw__updatestats___axiom
 use        Cw__movetrain__t___axiom as Cw__movetrain__t___axiom
 use        Cw__loadedrods___axiom as Cw__loadedrods___axiom
 use        Ada__text_io__count___axiom as Ada__text_io__count___axiom
 use        Ada__text_io__line_length__2___axiom as Ada__text_io__line_length__2___axiom
 use        Ada__text_io__page_length__2___axiom as Ada__text_io__page_length__2___axiom
 use        Ada__text_io__put__4___axiom as Ada__text_io__put__4___axiom
 use        Ada__float_text_io__put__2___axiom as Ada__float_text_io__put__2___axiom
 use        Cw__TwaterB___axiom as Cw__TwaterB___axiom

 let def [#"cw.ads" 79 0 0][@GP_Subp:cw.ads:79] 
   (__void_param : unit)
  requires { [#"cw.ads" 79 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:79 *)
  ;
  [#"cw.ads" 79 0 0] assume { [#"cw.ads" 79 0 0] (Cw__train___axiom.dynamic_invariant { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content } True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:79 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:79 *)
  ;
  [#"cw.ads" 79 0 0] begin ensures {true} let _ = (let _ = (Boolean.andb(((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int))) (((Cw__loadedrods___axiom.loadedrods({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content })) > (0 : int)))) in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:79 *)
  ;
  [#"cw.ads" 79 0 0] assume { [#"cw.ads" 79 0 0] ( ( [@GP_Pretty_Ada:4311] ((Cw__moving__rep.to_rep { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving) = (1 : int)) ) /\ ( [@GP_Pretty_Ada:4317] ((epsilon temp___result_572 : int.
   ( (temp___result_572 = (Cw__loadedrods.loadedrods { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content })) /\ (Cw__loadedrods.loadedrods__function_guard temp___result_572 { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }) )) > (0 : int)) ) ) };
  [#"cw.ads" 79 0 0] try
   ( ();
   ([#"cw.adb" 121 0 0] ( [#"cw.adb" 121 0 0] assume { [#"cw.adb" 121 0 0] (Standard__float___axiom.default_initial_assumption Cw__movetrain__distancemade.distancemade.Float32.t__content False) };
   [#"cw.adb" 121 0 0] assume { [#"cw.adb" 121 0 0] (Standard__float___axiom.dynamic_invariant Cw__movetrain__distancemade.distancemade.Float32.t__content False False True True) } ));
   ([#"cw.adb" 122 0 0] ( [#"cw.adb" 122 0 0] assume { [#"cw.adb" 122 0 0] (Standard__float___axiom.default_initial_assumption Cw__movetrain__hoursonheat.hoursonheat.Float32.t__content False) };
   [#"cw.adb" 122 0 0] assume { [#"cw.adb" 122 0 0] (Standard__float___axiom.dynamic_invariant Cw__movetrain__hoursonheat.hoursonheat.Float32.t__content False False True True) } ));
   ();
   ( [@GP_Sloc:cw.adb:124:7] ([#"cw.adb" 124 0 0] (if (( ([#"cw.adb" 124 0 0] [#"cw.adb" 124 0 0] (([@branch_id=3158] Main.spark__branch).bool__content <- ( ((Cw__moving__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__ismoving)) = (1 : int)) )));
   ( [@branch_id=3158] Main.spark__branch ).bool__content )) then (
    ( ();
    ( [@GP_Sloc:cw.adb:125:10] ([#"cw.adb" 125 0 0] ()) );
    ( [@GP_Sloc:cw.adb:125:10] ([#"cw.adb" 125 0 0] ( ([#"cw.adb" 125 0 0] ( [@GP_Sloc:cw.adb:125:10] [@GP_Reason:VC_PRECONDITION] [@GP_Shape:if__call_updatestats] [@GP_Id:46] [@vc:annotation] [@comment:         UpdateStats(t);          ^ cw.adb:125:10:VC_PRECONDITION] (Cw__updatestats___axiom.updatestats(Cw__movetrain__t.t__split_fields)) )) )) );
    ( [@GP_Sloc:cw.adb:127:10] ([#"cw.adb" 127 0 0] ()) );
    ( [@GP_Sloc:cw.adb:127:23] ([#"cw.adb" 127 0 0] [#"cw.adb" 127 0 0] (Cw__movetrain__distancemade.distancemade.Float32.t__content <- ( (Float32.mul_rne(([#"cw.adb" 127 0 0] ( [@vc:annotation] [@GP_Shape:if__distancemade_assign__typeconv__mult__typeconv__div] [@GP_Reason:VC_RANGE_CHECK] [@GP_Sloc:cw.adb:127:56] [@comment:         distanceMade := Float(Speed(t.stats.waterTank / Water(t.stats.waterDepletion)) * t.stats.currMaxSpeed);                                                        ^ cw.adb:127:56:VC_RANGE_CHECK] [@GP_Id:50] (Cw__speed.range_check_(([#"cw.adb" 127 0 0] ( [@GP_Reason:VC_FP_OVERFLOW_CHECK] [@vc:annotation] [@GP_Id:49] [@GP_Shape:if__distancemade_assign__typeconv__mult__typeconv__div] [@GP_Sloc:cw.adb:127:56] [@comment:         distanceMade := Float(Speed(t.stats.waterTank / Water(t.stats.waterDepletion)) * t.stats.currMaxSpeed);                                                        ^ cw.adb:127:56:VC_FP_OVERFLOW_CHECK] (Cw__TwaterB.range_check_(([#"cw.adb" 127 0 0] ( [@GP_Id:48] [@vc:annotation] [@GP_Reason:VC_DIVISION_CHECK] [@GP_Shape:if__distancemade_assign__typeconv__mult__typeconv__div] [@comment:         distanceMade := Float(Speed(t.stats.waterTank / Water(t.stats.waterDepletion)) * t.stats.currMaxSpeed);                                                        ^ cw.adb:127:56:VC_DIVISION_CHECK] [@GP_Sloc:cw.adb:127:56] (Float32.div_rne_((Cw__water__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank))) ((Float32.of_int_rne((Cw__depleterrange__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__waterdepletion)))))) )))) )))) ))) ((Cw__speed__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currmaxspeed)))) ))) );
    ( [@GP_Sloc:cw.adb:128:28] ([#"cw.adb" 128 0 0] (let temp___563 [@mlw:proxy_symbol] [@introduced] = (let temp___562 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content } in (
     ( [#"cw.adb" 128 0 0] begin ensures {true} let _ = (let _ = temp___562.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ()))
      in () end ;
     { ( temp___562 ) with Cw__train.__split_fields = { ( temp___562.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___561 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
      ( [#"cw.adb" 128 0 0] begin ensures {true} let _ = (let _ = temp___561.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank in (
       ()))
       in () end ;
      { ( temp___561 ) with Cw__trainrecord.__split_fields = { ( temp___561.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__watertank = (Cw__water__rep.of_rep((0.0E-1:Float32.t))) } } )))
      } } )))
     in (
     [#"cw.adb" 128 0 0] (Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___563.Cw__train.__split_fields ))))
    ) );
    ( [@GP_Sloc:cw.adb:130:10] ([#"cw.adb" 130 0 0] (if (( ([#"cw.adb" 130 0 0] [#"cw.adb" 130 0 0] (([@branch_id=3200] Main.spark__branch).bool__content <- ( (Float32.eq((Cw__water__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__watertank))) ((0.0E-1:Float32.t))) )));
    ( [@branch_id=3200] Main.spark__branch ).bool__content )) then (
     ( ();
     ( [@GP_Sloc:cw.adb:132:13] ([#"cw.adb" 132 0 0] ()) );
     ( [@GP_Sloc:cw.adb:132:25] ([#"cw.adb" 132 0 0] [#"cw.adb" 132 0 0] (Cw__movetrain__hoursonheat.hoursonheat.Float32.t__content <- ( ([#"cw.adb" 132 0 0] ( [@GP_Reason:VC_FP_OVERFLOW_CHECK] [@comment:            hoursOnHeat := Float(Heat'Last - t.stats.temperature) / Float(t.stats.tempIncreaser);                                                                   ^ cw.adb:132:67:VC_FP_OVERFLOW_CHECK] [@vc:annotation] [@GP_Shape:if__if__hoursonheat_assign__div] [@GP_Sloc:cw.adb:132:67] [@GP_Id:55] (Standard__float.range_check_(([#"cw.adb" 132 0 0] ( [@comment:            hoursOnHeat := Float(Heat'Last - t.stats.temperature) / Float(t.stats.tempIncreaser);                                                                   ^ cw.adb:132:67:VC_DIVISION_CHECK] [@vc:annotation] [@GP_Reason:VC_DIVISION_CHECK] [@GP_Shape:if__if__hoursonheat_assign__div] [@GP_Sloc:cw.adb:132:67] [@GP_Id:54] (Float32.div_rne_((Float32.sub_rne((500.0:Float32.t)) ((Cw__heat__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__temperature))))) ((Float32.of_int_rne((Cw__increaserrange__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__tempincreaser)))))) )))) )) ))) );
     ( [@GP_Sloc:cw.adb:133:13] ([#"cw.adb" 133 0 0] ()) );
     ( [@GP_Sloc:cw.adb:133:29] ([#"cw.adb" 133 0 0] ()) );
     ( [@GP_Sloc:cw.adb:133:44] ([#"cw.adb" 133 0 0] ()) );
     ( [@GP_Sloc:cw.adb:133:26] ([#"cw.adb" 133 0 0] [#"cw.adb" 133 0 0] (Cw__movetrain__distancemade.distancemade.Float32.t__content <- ( ([#"cw.adb" 133 0 0] ( [@GP_Id:57] [@GP_Reason:VC_FP_OVERFLOW_CHECK] [@vc:annotation] [@comment:            distanceMade := distanceMade + hoursOnHeat * Float(t.stats.currMaxSpeed);                                          ^ cw.adb:133:42:VC_FP_OVERFLOW_CHECK] [@GP_Sloc:cw.adb:133:42] [@GP_Shape:if__if__distancemade_assign__add] (Standard__float.range_check_((Float32.add_rne(Cw__movetrain__distancemade.distancemade.Float32.t__content) (([#"cw.adb" 133 0 0] ( [@GP_Id:56] [@comment:            distanceMade := distanceMade + hoursOnHeat * Float(t.stats.currMaxSpeed);                                                        ^ cw.adb:133:56:VC_FP_OVERFLOW_CHECK] [@GP_Shape:if__if__distancemade_assign__add__mult] [@GP_Reason:VC_FP_OVERFLOW_CHECK] [@GP_Sloc:cw.adb:133:56] [@vc:annotation] (Standard__float.range_check_((Float32.mul_rne(Cw__movetrain__hoursonheat.hoursonheat.Float32.t__content) ((Cw__speed__rep.to_rep({ Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__currmaxspeed)))))) )))))) )) ))) );
     ( [@GP_Sloc:cw.adb:135:33] ([#"cw.adb" 135 0 0] (let temp___566 [@mlw:proxy_symbol] [@introduced] = (let temp___565 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content } in (
      ( [#"cw.adb" 135 0 0] begin ensures {true} let _ = (let _ = temp___565.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
       ()))
       in () end ;
      { ( temp___565 ) with Cw__train.__split_fields = { ( temp___565.Cw__train.__split_fields ) with Cw__train.rec__cw__train__stats = (let temp___564 [@mlw:proxy_symbol] [@introduced] = { Cw__train.__split_fields = Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content }.Cw__train.__split_fields.Cw__train.rec__cw__train__stats in (
       ( [#"cw.adb" 135 0 0] begin ensures {true} let _ = (let _ = temp___564.Cw__trainrecord.__split_fields.Cw__trainrecord.rec__cw__trainrecord__temperature in (
        ()))
        in () end ;
       { ( temp___564 ) with Cw__trainrecord.__split_fields = { ( temp___564.Cw__trainrecord.__split_fields ) with Cw__trainrecord.rec__cw__trainrecord__temperature = (Cw__heat__rep.of_rep((500.0:Float32.t))) } } )))
       } } )))
      in (
      [#"cw.adb" 135 0 0] (Cw__movetrain__t.t__split_fields.Cw__train.__split_fields__content <- ( temp___566.Cw__train.__split_fields ))))
     ) ) )) else (
     ()))) );
    ( [@GP_Sloc:cw.adb:137:10] ([#"cw.adb" 137 0 0] ()) );
    ( [@GP_Sloc:cw.adb:137:10] ([#"cw.adb" 137 0 0] ( (Ada__text_io__put__4___axiom.put__4((Standard__string.of_array((Temp___String_Literal_567.temp___String_Literal_567(()))) ((1 : int)) ((25 : int))))) )) );
    ( [@GP_Sloc:cw.adb:137:48] ([#"cw.adb" 137 0 0] ()) );
    ( [@GP_Sloc:cw.adb:137:44] ([#"cw.adb" 137 0 0] ()) );
    ( [@GP_Sloc:cw.adb:137:44] ([#"cw.adb" 137 0 0] ( (Ada__float_text_io__put__2___axiom.put__2(Cw__movetrain__distancemade.distancemade.Float32.t__content) ((1 : int)) ((4 : int)) ((0 : int))) )) ) )) else (
    ()))) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "connectedcarriages" defined at cw.ads:82, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Cw__connectedcarriages__subprogram_def
 use        "_gnatprove_standard".Main
 use        "int".Int
 use        "int".Int
 use        "_gnatprove_standard".Main as Main
 use        Cw__train as Cw__train
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__connectedcarriages__t as Cw__connectedcarriages__t
 use        Cw__connectedcarriages__count as Cw__connectedcarriages__count
 use        Cw__connectedcarriages__L_3__j as Cw__connectedcarriages__L_3__j
 use        Cw__carriageslot as Cw__carriageslot
 use        Cw__carriageslot__rep as Cw__carriageslot__rep
 use        Cw__carriagecounter as Cw__carriagecounter
 use        Cw__carriagecounter___axiom as Cw__carriagecounter___axiom
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__traincarriage as Cw__traincarriage
 use        Cw__connectedcarriages__L_3 as Cw__connectedcarriages__L_3
 use        Array__Int__Cw__carriageslot as Array__Int__Cw__carriageslot
 use        Cw__connectedcarriages__count___axiom as Cw__connectedcarriages__count___axiom
 use        Cw__connectedcarriages__L_3__j___axiom as Cw__connectedcarriages__L_3__j___axiom
 use        Cw__connectedcarriages__L_3___axiom as Cw__connectedcarriages__L_3___axiom
 use        Cw__carriageslot___axiom as Cw__carriageslot___axiom
 use        Cw__moving___axiom as Cw__moving___axiom
 use        Cw__rod___axiom as Cw__rod___axiom
 use        Cw__energy___axiom as Cw__energy___axiom
 use        Cw__heat___axiom as Cw__heat___axiom
 use        Cw__water___axiom as Cw__water___axiom
 use        Cw__speed___axiom as Cw__speed___axiom
 use        Cw__carriagerange___axiom as Cw__carriagerange___axiom
 use        Cw__carriagecounter___axiom as Cw__carriagecounter___axiom
 use        Cw__increaserrange___axiom as Cw__increaserrange___axiom
 use        Cw__depleterrange___axiom as Cw__depleterrange___axiom
 use        Cw__carriagearr___axiom as Cw__carriagearr___axiom
 use        Cw__reactorarr___axiom as Cw__reactorarr___axiom
 use        Cw__trainrecord___axiom as Cw__trainrecord___axiom
 use        Cw__traincarriage___axiom as Cw__traincarriage___axiom
 use        Cw__train___axiom as Cw__train___axiom
 use        Cw__connectedcarriages__t___axiom as Cw__connectedcarriages__t___axiom

 val cw__connectedcarriages__result [@name:ConnectedCarriages] [@model_trace:4318@result] [@model_projected]  : int__ref 
 
 let def [#"cw.ads" 82 0 0][@GP_Subp:cw.ads:82] 
   (__void_param : unit)
  requires { [#"cw.ads" 82 0 0] true }
   = [@vc:divergent]
  ( () (* Assume dynamic invariants of inputs of the subprogram cw.ads:82 *)
  ;
  [#"cw.ads" 82 0 0] assume { [#"cw.ads" 82 0 0] (Cw__train___axiom.dynamic_invariant Cw__connectedcarriages__t.t True False True True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram cw.ads:82 *)
  ;
  () (* Check for RTE in the Pre of the subprogram cw.ads:82 *)
  ;
  [#"cw.ads" 82 0 0] begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end ;
  () (* Assume Pre of the subprogram cw.ads:82 *)
  ;
  [#"cw.ads" 82 0 0] try
   ( ();
   ([#"cw.adb" 66 0 0] ( [#"cw.adb" 66 0 0] (Cw__connectedcarriages__count.count.int__content <- ( (0 : int) ));
   [#"cw.adb" 66 0 0] assume { [#"cw.adb" 66 0 0] (Cw__carriagecounter___axiom.dynamic_invariant Cw__connectedcarriages__count.count.int__content True False True True) } ));
   ([#"cw.adb" 69 0 0] ());
   ();
   ( [@GP_Sloc:cw.adb:69:43] ([#"cw.adb" 69 0 0] (let temp___573 [@mlw:proxy_symbol] [@introduced] = (0 : int) in (
   (let temp___574 [@mlw:proxy_symbol] [@introduced] = (10 : int) in (
    ( () (* Translation of an Ada loop from cw.adb:69 *)
    ;
    [#"cw.adb" 69 0 0] try
     ( [#"cw.adb" 69 0 0] begin ensures {true} let _ = (let _ = Cw__connectedcarriages__count.count.int__content in (
      ()))
      in () end ;
     (let temp___576 [@mlw:proxy_symbol] [@introduced] = [#"cw.adb" 69 0 0] (val _f : int
     ensures {[#"cw.adb" 69 0 0] (result = Cw__connectedcarriages__count.count.int__content)} 
     in _f) in (
      ( () (* Unrolling of the loop statements of loop cw.adb:69 *)
      ;
      [#"cw.adb" 69 0 0] (Cw__connectedcarriages__L_3__j.j.int__content <- ( (0 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (1 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (2 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (3 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (4 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (5 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (6 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (7 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (8 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (9 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) );
       (Cw__connectedcarriages__L_3__j.j.int__content <- ( (10 : int) ));
      ();
      ( [@GP_Sloc:cw.adb:70:10] ([#"cw.adb" 70 0 0] (if (( ([#"cw.adb" 70 0 0] [#"cw.adb" 70 0 0] (([@branch_id=2790] Main.spark__branch).bool__content <- ( ((Cw__carriageslot__rep.to_rep((let temp___575 [@mlw:proxy_symbol] [@introduced] = Cw__connectedcarriages__t.t.Cw__train.__split_fields.Cw__train.rec__cw__train__carriage.Cw__traincarriage.__split_fields.Cw__traincarriage.rec__cw__traincarriage__carriages in (
       (Array__Int__Cw__carriageslot.get(temp___575) (Cw__connectedcarriages__L_3__j.j.int__content))))
      )) = (1 : int)) )));
      ( [@branch_id=2790] Main.spark__branch ).bool__content )) then (
       ( ();
       ( [@GP_Sloc:cw.adb:71:13] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:22] ([#"cw.adb" 71 0 0] ()) );
       ( [@GP_Sloc:cw.adb:71:19] ([#"cw.adb" 71 0 0] [#"cw.adb" 71 0 0] (Cw__connectedcarriages__count.count.int__content <- ( ([#"cw.adb" 71 0 0] ( [@GP_Id:58] [@comment:            count := count +1;                            ^ cw.adb:71:28:VC_RANGE_CHECK] [@vc:annotation] [@GP_Reason:VC_RANGE_CHECK] [@GP_Shape:L_3_while__if__count_assign__add] [@GP_Sloc:cw.adb:71:28] (Cw__carriagecounter.range_check_((Cw__connectedcarriages__count.count.int__content + (1 : int)))) )) ))) ) )) else (
       ()))) ) )))
      )
    with
     Cw__connectedcarriages__L_3.L_3 -> ()
    end )))
   ))
   ) );
   ( [@GP_Sloc:cw.adb:76:14] ([#"cw.adb" 76 0 0] ()) );
   ( [@GP_Sloc:cw.adb:76:7] ([#"cw.adb" 76 0 0] ( [#"cw.adb" 76 0 0] (cw__connectedcarriages__result.int__content <- ( Cw__connectedcarriages__count.count.int__content ));
   [#"cw.adb" 76 0 0] raise Return__exc )) );
    raise Return__exc )
  with
   Return__exc -> ()
  end;
   begin ensures {true} let _ = (let _ = True in (
   ()))
   in () end ;
  cw__connectedcarriages__result.int__content )
end
